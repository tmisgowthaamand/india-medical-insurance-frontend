// src/index.ts
import {
  createConnection,
  TextDocuments,
  TextDocumentSyncKind,
  ConfigurationRequest
} from "vscode-languageserver/node";
import { TextDocument as TextDocument9 } from "vscode-languageserver-textdocument";

// src/vscode-css-languageservice/utils/strings.ts
function startsWith(haystack, needle) {
  if (haystack.length < needle.length) {
    return false;
  }
  for (let i = 0; i < needle.length; i++) {
    if (haystack[i] !== needle[i]) {
      return false;
    }
  }
  return true;
}
function endsWith(haystack, needle) {
  const diff = haystack.length - needle.length;
  if (diff > 0) {
    return haystack.lastIndexOf(needle) === diff;
  } else if (diff === 0) {
    return haystack === needle;
  } else {
    return false;
  }
}
function difference(first, second, maxLenDelta = 4) {
  const lengthDifference = Math.abs(first.length - second.length);
  if (lengthDifference > maxLenDelta) {
    return 0;
  }
  const LCS = [];
  const zeroArray = [];
  let i, j;
  for (i = 0; i < second.length + 1; ++i) {
    zeroArray.push(0);
  }
  for (i = 0; i < first.length + 1; ++i) {
    LCS.push(zeroArray);
  }
  for (i = 1; i < first.length + 1; ++i) {
    for (j = 1; j < second.length + 1; ++j) {
      if (first[i - 1] === second[j - 1]) {
        LCS[i][j] = LCS[i - 1][j - 1] + 1;
      } else {
        LCS[i][j] = Math.max(LCS[i - 1][j], LCS[i][j - 1]);
      }
    }
  }
  return LCS[first.length][second.length] - Math.sqrt(lengthDifference);
}
function getLimitedString(str, ellipsis = true) {
  if (!str) {
    return "";
  }
  if (str.length < 140) {
    return str;
  }
  return str.slice(0, 140) + (ellipsis ? "\u2026" : "");
}
function trim(str, regexp) {
  const m = regexp.exec(str);
  if (m && m[0].length) {
    return str.substr(0, str.length - m[0].length);
  }
  return str;
}

// src/vscode-css-languageservice/parser/cssNodes.ts
function getNodeAtOffset(node, offset) {
  let candidate = null;
  if (!node || offset < node.offset || offset > node.end) {
    return null;
  }
  node.accept((node2) => {
    if (node2.offset === -1 && node2.length === -1) {
      return true;
    }
    if (node2.offset <= offset && node2.end >= offset) {
      if (!candidate) {
        candidate = node2;
      } else if (node2.length <= candidate.length) {
        candidate = node2;
      }
      return true;
    }
    return false;
  });
  return candidate;
}
function getNodePath(node, offset) {
  let candidate = getNodeAtOffset(node, offset);
  const path = [];
  while (candidate) {
    path.unshift(candidate);
    candidate = candidate.parent;
  }
  return path;
}
function getParentDeclaration(node) {
  const decl = node.findParent(19 /* Declaration */);
  const value = decl && decl.getValue();
  if (value && value.encloses(node)) {
    return decl;
  }
  return null;
}
var Node = class {
  get end() {
    return this.offset + this.length;
  }
  constructor(offset = -1, len = -1, nodeType) {
    this.parent = null;
    this.offset = offset;
    this.length = len;
    if (nodeType) {
      this.nodeType = nodeType;
    }
  }
  set type(type) {
    this.nodeType = type;
  }
  get type() {
    return this.nodeType || 0 /* Undefined */;
  }
  getTextProvider() {
    let node = this;
    while (node && !node.textProvider) {
      node = node.parent;
    }
    if (node) {
      return node.textProvider;
    }
    return () => {
      return "unknown";
    };
  }
  getText() {
    return this.getTextProvider()(this.offset, this.length);
  }
  matches(str) {
    return this.length === str.length && this.getTextProvider()(this.offset, this.length) === str;
  }
  startsWith(str) {
    return this.length >= str.length && this.getTextProvider()(this.offset, str.length) === str;
  }
  endsWith(str) {
    return this.length >= str.length && this.getTextProvider()(this.end - str.length, str.length) === str;
  }
  accept(visitor) {
    if (visitor(this) && this.children) {
      for (const child of this.children) {
        child.accept(visitor);
      }
    }
  }
  acceptVisitor(visitor) {
    this.accept(visitor.visitNode.bind(visitor));
  }
  adoptChild(node, index = -1) {
    if (node.parent && node.parent.children) {
      const idx = node.parent.children.indexOf(node);
      if (idx >= 0) {
        node.parent.children.splice(idx, 1);
      }
    }
    node.parent = this;
    let children = this.children;
    if (!children) {
      children = this.children = [];
    }
    if (index !== -1) {
      children.splice(index, 0, node);
    } else {
      children.push(node);
    }
    return node;
  }
  attachTo(parent, index = -1) {
    if (parent) {
      parent.adoptChild(this, index);
    }
    return this;
  }
  collectIssues(results) {
    if (this.issues) {
      results.push.apply(results, this.issues);
    }
  }
  addIssue(issue) {
    if (!this.issues) {
      this.issues = [];
    }
    this.issues.push(issue);
  }
  hasIssue(rule) {
    return Array.isArray(this.issues) && this.issues.some((i) => i.getRule() === rule);
  }
  isErroneous(recursive = false) {
    if (this.issues && this.issues.length > 0) {
      return true;
    }
    return recursive && Array.isArray(this.children) && this.children.some((c) => c.isErroneous(true));
  }
  setNode(field, node, index = -1) {
    if (node) {
      node.attachTo(this, index);
      this[field] = node;
      return true;
    }
    return false;
  }
  addChild(node) {
    if (node) {
      if (!this.children) {
        this.children = [];
      }
      node.attachTo(this);
      this.updateOffsetAndLength(node);
      return true;
    }
    return false;
  }
  updateOffsetAndLength(node) {
    if (node.offset < this.offset || this.offset === -1) {
      this.offset = node.offset;
    }
    const nodeEnd = node.end;
    if (nodeEnd > this.end || this.length === -1) {
      this.length = nodeEnd - this.offset;
    }
  }
  hasChildren() {
    return !!this.children && this.children.length > 0;
  }
  getChildren() {
    return this.children ? this.children.slice(0) : [];
  }
  getChild(index) {
    if (this.children && index < this.children.length) {
      return this.children[index];
    }
    return null;
  }
  addChildren(nodes) {
    for (const node of nodes) {
      this.addChild(node);
    }
  }
  findFirstChildBeforeOffset(offset) {
    if (this.children) {
      let current = null;
      for (let i = this.children.length - 1; i >= 0; i--) {
        current = this.children[i];
        if (current.offset <= offset) {
          return current;
        }
      }
    }
    return null;
  }
  findChildAtOffset(offset, goDeep) {
    const current = this.findFirstChildBeforeOffset(offset);
    if (current && current.end >= offset) {
      if (goDeep) {
        return current.findChildAtOffset(offset, true) || current;
      }
      return current;
    }
    return null;
  }
  encloses(candidate) {
    return this.offset <= candidate.offset && this.offset + this.length >= candidate.offset + candidate.length;
  }
  getParent() {
    let result = this.parent;
    while (result instanceof Nodelist) {
      result = result.parent;
    }
    return result;
  }
  findParent(type) {
    let result = this;
    while (result && result.type !== type) {
      result = result.parent;
    }
    return result;
  }
  findAParent(...types) {
    let result = this;
    while (result && !types.some((t) => result.type === t)) {
      result = result.parent;
    }
    return result;
  }
  setData(key, value) {
    if (!this.options) {
      this.options = {};
    }
    this.options[key] = value;
  }
  getData(key) {
    if (!this.options || !this.options.hasOwnProperty(key)) {
      return null;
    }
    return this.options[key];
  }
};
var Nodelist = class extends Node {
  constructor(parent, index = -1) {
    super(-1, -1);
    this.attachTo(parent, index);
    this.offset = -1;
    this.length = -1;
  }
};
var UnicodeRange = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 82 /* UnicodeRange */;
  }
  setRangeStart(rangeStart) {
    return this.setNode("rangeStart", rangeStart);
  }
  getRangeStart() {
    return this.rangeStart;
  }
  setRangeEnd(rangeEnd) {
    return this.setNode("rangeEnd", rangeEnd);
  }
  getRangeEnd() {
    return this.rangeEnd;
  }
};
var Identifier = class extends Node {
  constructor(offset, length) {
    super(offset, length);
    this.isCustomProperty = false;
  }
  get type() {
    return 1 /* Identifier */;
  }
  containsInterpolation() {
    return this.hasChildren();
  }
};
var Stylesheet = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 2 /* Stylesheet */;
  }
};
var Declarations = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 20 /* Declarations */;
  }
};
var BodyDeclaration = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  getDeclarations() {
    return this.declarations;
  }
  setDeclarations(decls) {
    return this.setNode("declarations", decls);
  }
};
var RuleSet = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 3 /* Ruleset */;
  }
  getSelectors() {
    if (!this.selectors) {
      this.selectors = new Nodelist(this);
    }
    return this.selectors;
  }
  isNested() {
    return !!this.parent && this.parent.findParent(20 /* Declarations */) !== null;
  }
};
var Selector = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 4 /* Selector */;
  }
};
var SimpleSelector = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 5 /* SimpleSelector */;
  }
};
var AbstractDeclaration = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
};
var CustomPropertySet = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 69 /* CustomPropertySet */;
  }
};
var Declaration = class extends AbstractDeclaration {
  constructor(offset, length) {
    super(offset, length);
    this.property = null;
  }
  get type() {
    return 19 /* Declaration */;
  }
  setProperty(node) {
    return this.setNode("property", node);
  }
  getProperty() {
    return this.property;
  }
  getFullPropertyName() {
    const propertyName = this.property ? this.property.getName() : "unknown";
    if (this.parent instanceof Declarations && this.parent.getParent() instanceof NestedProperties) {
      const parentDecl = this.parent.getParent().getParent();
      if (parentDecl instanceof Declaration) {
        return parentDecl.getFullPropertyName() + propertyName;
      }
    }
    return propertyName;
  }
  getNonPrefixedPropertyName() {
    const propertyName = this.getFullPropertyName();
    if (propertyName && propertyName.charAt(0) === "-") {
      const vendorPrefixEnd = propertyName.indexOf("-", 1);
      if (vendorPrefixEnd !== -1) {
        return propertyName.substring(vendorPrefixEnd + 1);
      }
    }
    return propertyName;
  }
  setValue(value) {
    return this.setNode("value", value);
  }
  getValue() {
    return this.value;
  }
  setNestedProperties(value) {
    return this.setNode("nestedProperties", value);
  }
  getNestedProperties() {
    return this.nestedProperties;
  }
};
var CustomPropertyDeclaration = class extends Declaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 68 /* CustomPropertyDeclaration */;
  }
  setPropertySet(value) {
    return this.setNode("propertySet", value);
  }
  getPropertySet() {
    return this.propertySet;
  }
};
var Property = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 21 /* Property */;
  }
  setIdentifier(value) {
    return this.setNode("identifier", value);
  }
  getIdentifier() {
    return this.identifier;
  }
  getName() {
    return trim(this.getText(), /[_\+]+$/);
  }
  isCustomProperty() {
    return !!this.identifier && this.identifier.isCustomProperty;
  }
};
var Invocation = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 56 /* Invocation */;
  }
  getArguments() {
    if (!this.arguments) {
      this.arguments = new Nodelist(this);
    }
    return this.arguments;
  }
};
var Function = class extends Invocation {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 30 /* Function */;
  }
  setIdentifier(node) {
    return this.setNode("identifier", node, 0);
  }
  getIdentifier() {
    return this.identifier;
  }
  getName() {
    return this.identifier ? this.identifier.getText() : "";
  }
};
var FunctionParameter = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 62 /* FunctionParameter */;
  }
  setIdentifier(node) {
    return this.setNode("identifier", node, 0);
  }
  getIdentifier() {
    return this.identifier;
  }
  getName() {
    return this.identifier ? this.identifier.getText() : "";
  }
  setDefaultValue(node) {
    return this.setNode("defaultValue", node, 0);
  }
  getDefaultValue() {
    return this.defaultValue;
  }
};
var FunctionArgument = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 63 /* FunctionArgument */;
  }
  setIdentifier(node) {
    return this.setNode("identifier", node, 0);
  }
  getIdentifier() {
    return this.identifier;
  }
  getName() {
    return this.identifier ? this.identifier.getText() : "";
  }
  setValue(node) {
    return this.setNode("value", node, 0);
  }
  getValue() {
    return this.value;
  }
};
var IfStatement = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 44 /* If */;
  }
  setExpression(node) {
    return this.setNode("expression", node, 0);
  }
  setElseClause(elseClause) {
    return this.setNode("elseClause", elseClause);
  }
};
var ForStatement = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 46 /* For */;
  }
  setVariable(node) {
    return this.setNode("variable", node, 0);
  }
};
var EachStatement = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 47 /* Each */;
  }
  getVariables() {
    if (!this.variables) {
      this.variables = new Nodelist(this);
    }
    return this.variables;
  }
};
var WhileStatement = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 48 /* While */;
  }
};
var ElseStatement = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 45 /* Else */;
  }
};
var FunctionDeclaration = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 57 /* FunctionDeclaration */;
  }
  setIdentifier(node) {
    return this.setNode("identifier", node, 0);
  }
  getIdentifier() {
    return this.identifier;
  }
  getName() {
    return this.identifier ? this.identifier.getText() : "";
  }
  getParameters() {
    if (!this.parameters) {
      this.parameters = new Nodelist(this);
    }
    return this.parameters;
  }
};
var ViewPort = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 65 /* ViewPort */;
  }
};
var FontFace = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 53 /* FontFace */;
  }
};
var NestedProperties = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 40 /* NestedProperties */;
  }
};
var Keyframe = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 52 /* Keyframe */;
  }
  setKeyword(keyword) {
    return this.setNode("keyword", keyword, 0);
  }
  getKeyword() {
    return this.keyword;
  }
  setIdentifier(node) {
    return this.setNode("identifier", node, 0);
  }
  getIdentifier() {
    return this.identifier;
  }
  getName() {
    return this.identifier ? this.identifier.getText() : "";
  }
};
var KeyframeSelector = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 64 /* KeyframeSelector */;
  }
};
var Import = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 54 /* Import */;
  }
  setMedialist(node) {
    if (node) {
      node.attachTo(this);
      return true;
    }
    return false;
  }
};
var Use = class extends Node {
  get type() {
    return 77 /* Use */;
  }
  getParameters() {
    if (!this.parameters) {
      this.parameters = new Nodelist(this);
    }
    return this.parameters;
  }
  setIdentifier(node) {
    return this.setNode("identifier", node, 0);
  }
  getIdentifier() {
    return this.identifier;
  }
};
var ModuleConfiguration = class extends Node {
  get type() {
    return 78 /* ModuleConfiguration */;
  }
  setIdentifier(node) {
    return this.setNode("identifier", node, 0);
  }
  getIdentifier() {
    return this.identifier;
  }
  getName() {
    return this.identifier ? this.identifier.getText() : "";
  }
  setValue(node) {
    return this.setNode("value", node, 0);
  }
  getValue() {
    return this.value;
  }
};
var Forward = class extends Node {
  get type() {
    return 79 /* Forward */;
  }
  setIdentifier(node) {
    return this.setNode("identifier", node, 0);
  }
  getIdentifier() {
    return this.identifier;
  }
  getMembers() {
    if (!this.members) {
      this.members = new Nodelist(this);
    }
    return this.members;
  }
  getParameters() {
    if (!this.parameters) {
      this.parameters = new Nodelist(this);
    }
    return this.parameters;
  }
};
var ForwardVisibility = class extends Node {
  get type() {
    return 80 /* ForwardVisibility */;
  }
  setIdentifier(node) {
    return this.setNode("identifier", node, 0);
  }
  getIdentifier() {
    return this.identifier;
  }
};
var Namespace = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 55 /* Namespace */;
  }
};
var Media = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 51 /* Media */;
  }
};
var Supports = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 71 /* Supports */;
  }
};
var Layer = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 83 /* Layer */;
  }
  setNames(names) {
    return this.setNode("names", names);
  }
  getNames() {
    return this.names;
  }
};
var Document = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 66 /* Document */;
  }
};
var Medialist = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
};
var MediaQuery = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 59 /* MediaQuery */;
  }
};
var MediaCondition = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 60 /* MediaCondition */;
  }
};
var MediaFeature = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 61 /* MediaFeature */;
  }
};
var SupportsCondition = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 72 /* SupportsCondition */;
  }
};
var Page = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 12 /* Page */;
  }
};
var PageBoxMarginBox = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 13 /* PageBoxMarginBox */;
  }
};
var Expression = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 22 /* Expression */;
  }
};
var BinaryExpression = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 23 /* BinaryExpression */;
  }
  setLeft(left) {
    return this.setNode("left", left);
  }
  getLeft() {
    return this.left;
  }
  setRight(right) {
    return this.setNode("right", right);
  }
  getRight() {
    return this.right;
  }
  setOperator(value) {
    return this.setNode("operator", value);
  }
  getOperator() {
    return this.operator;
  }
};
var Term = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 24 /* Term */;
  }
  setOperator(value) {
    return this.setNode("operator", value);
  }
  getOperator() {
    return this.operator;
  }
  setExpression(value) {
    return this.setNode("expression", value);
  }
  getExpression() {
    return this.expression;
  }
};
var AttributeSelector = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 18 /* AttributeSelector */;
  }
  setNamespacePrefix(value) {
    return this.setNode("namespacePrefix", value);
  }
  getNamespacePrefix() {
    return this.namespacePrefix;
  }
  setIdentifier(value) {
    return this.setNode("identifier", value);
  }
  getIdentifier() {
    return this.identifier;
  }
  setOperator(operator) {
    return this.setNode("operator", operator);
  }
  getOperator() {
    return this.operator;
  }
  setValue(value) {
    return this.setNode("value", value);
  }
  getValue() {
    return this.value;
  }
};
var HexColorValue = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 32 /* HexColorValue */;
  }
};
var RatioValue = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 33 /* RatioValue */;
  }
};
var _dot = ".".charCodeAt(0);
var _0 = "0".charCodeAt(0);
var _9 = "9".charCodeAt(0);
var NumericValue = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 31 /* NumericValue */;
  }
  getValue() {
    const raw = this.getText();
    let unitIdx = 0;
    let code;
    for (let i = 0, len = raw.length; i < len; i++) {
      code = raw.charCodeAt(i);
      if (!(_0 <= code && code <= _9 || code === _dot)) {
        break;
      }
      unitIdx += 1;
    }
    return {
      value: raw.substring(0, unitIdx),
      unit: unitIdx < raw.length ? raw.substring(unitIdx) : void 0
    };
  }
};
var VariableDeclaration = class extends AbstractDeclaration {
  constructor(offset, length) {
    super(offset, length);
    this.needsSemicolon = true;
  }
  get type() {
    return 37 /* VariableDeclaration */;
  }
  setVariable(node) {
    if (node) {
      node.attachTo(this);
      this.variable = node;
      return true;
    }
    return false;
  }
  getVariable() {
    return this.variable;
  }
  getName() {
    return this.variable ? this.variable.getName() : "";
  }
  setValue(node) {
    if (node) {
      node.attachTo(this);
      this.value = node;
      return true;
    }
    return false;
  }
  getValue() {
    return this.value;
  }
};
var Interpolation = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 39 /* Interpolation */;
  }
};
var Variable = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 36 /* VariableName */;
  }
  getName() {
    return this.getText();
  }
};
var ExtendsReference = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 41 /* ExtendsReference */;
  }
  getSelectors() {
    if (!this.selectors) {
      this.selectors = new Nodelist(this);
    }
    return this.selectors;
  }
};
var MixinContentReference = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 49 /* MixinContentReference */;
  }
  getArguments() {
    if (!this.arguments) {
      this.arguments = new Nodelist(this);
    }
    return this.arguments;
  }
};
var MixinContentDeclaration = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 49 /* MixinContentReference */;
  }
  getParameters() {
    if (!this.parameters) {
      this.parameters = new Nodelist(this);
    }
    return this.parameters;
  }
};
var MixinReference = class extends Node {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 35 /* MixinReference */;
  }
  getNamespaces() {
    if (!this.namespaces) {
      this.namespaces = new Nodelist(this);
    }
    return this.namespaces;
  }
  setIdentifier(node) {
    return this.setNode("identifier", node, 0);
  }
  getIdentifier() {
    return this.identifier;
  }
  getName() {
    return this.identifier ? this.identifier.getText() : "";
  }
  getArguments() {
    if (!this.arguments) {
      this.arguments = new Nodelist(this);
    }
    return this.arguments;
  }
  setContent(node) {
    return this.setNode("content", node);
  }
  getContent() {
    return this.content;
  }
};
var MixinDeclaration = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 34 /* MixinDeclaration */;
  }
  setIdentifier(node) {
    return this.setNode("identifier", node, 0);
  }
  getIdentifier() {
    return this.identifier;
  }
  getName() {
    return this.identifier ? this.identifier.getText() : "";
  }
  getParameters() {
    if (!this.parameters) {
      this.parameters = new Nodelist(this);
    }
    return this.parameters;
  }
  setGuard(node) {
    if (node) {
      node.attachTo(this);
      this.guard = node;
    }
    return false;
  }
};
var UnknownAtRule = class extends BodyDeclaration {
  constructor(offset, length) {
    super(offset, length);
  }
  get type() {
    return 76 /* UnknownAtRule */;
  }
  setAtRuleName(atRuleName) {
    this.atRuleName = atRuleName;
  }
  getAtRuleName() {
    return this.atRuleName;
  }
};
var ListEntry = class extends Node {
  get type() {
    return 70 /* ListEntry */;
  }
  setKey(node) {
    return this.setNode("key", node, 0);
  }
  setValue(node) {
    return this.setNode("value", node, 1);
  }
};
var Module = class extends Node {
  get type() {
    return 81 /* Module */;
  }
  setIdentifier(node) {
    return this.setNode("identifier", node, 0);
  }
  getIdentifier() {
    return this.identifier;
  }
};
var Marker = class {
  constructor(node, rule, level, message, offset = node.offset, length = node.length) {
    this.node = node;
    this.rule = rule;
    this.level = level;
    this.message = message || rule.message;
    this.offset = offset;
    this.length = length;
  }
  getRule() {
    return this.rule;
  }
  getLevel() {
    return this.level;
  }
  getOffset() {
    return this.offset;
  }
  getLength() {
    return this.length;
  }
  getNode() {
    return this.node;
  }
  getMessage() {
    return this.message;
  }
};
var ParseErrorCollector = class {
  static entries(node) {
    const visitor = new ParseErrorCollector();
    node.acceptVisitor(visitor);
    return visitor.entries;
  }
  constructor() {
    this.entries = [];
  }
  visitNode(node) {
    if (node.isErroneous()) {
      node.collectIssues(this.entries);
    }
    return true;
  }
};

// src/vscode-css-languageservice/cssLanguageTypes.ts
import {
  Range,
  Position,
  DocumentUri,
  MarkupContent,
  MarkupKind,
  Color,
  ColorInformation,
  ColorPresentation,
  FoldingRange,
  FoldingRangeKind,
  SelectionRange,
  Diagnostic,
  DiagnosticSeverity,
  CompletionItem,
  CompletionItemKind,
  CompletionList,
  CompletionItemTag,
  InsertTextFormat,
  DefinitionLink,
  SymbolInformation,
  SymbolKind,
  DocumentSymbol,
  Location,
  Hover,
  MarkedString,
  CodeActionContext,
  Command,
  CodeAction,
  DocumentHighlight,
  DocumentLink,
  WorkspaceEdit,
  TextEdit,
  CodeActionKind,
  TextDocumentEdit,
  VersionedTextDocumentIdentifier,
  DocumentHighlightKind
} from "vscode-languageserver-types";
import { TextDocument } from "vscode-languageserver-textdocument";
var ClientCapabilities;
((ClientCapabilities3) => {
  ClientCapabilities3.LATEST = {
    textDocument: {
      completion: {
        completionItem: {
          documentationFormat: [MarkupKind.Markdown, MarkupKind.PlainText]
        }
      },
      hover: {
        contentFormat: [MarkupKind.Markdown, MarkupKind.PlainText]
      }
    }
  };
})(ClientCapabilities || (ClientCapabilities = {}));

// src/vscode-css-languageservice/languageFacts/entry.ts
var browserNames = {
  E: "Edge",
  FF: "Firefox",
  S: "Safari",
  C: "Chrome",
  IE: "IE",
  O: "Opera"
};
function getEntryStatus(status) {
  switch (status) {
    case "experimental":
      return "\u26A0\uFE0F Property is experimental. Be cautious when using it.\uFE0F\n\n";
    case "nonstandard":
      return "\u{1F6A8}\uFE0F Property is nonstandard. Avoid using it.\n\n";
    case "obsolete":
      return "\u{1F6A8}\uFE0F\uFE0F\uFE0F Property is obsolete. Avoid using it.\n\n";
    default:
      return "";
  }
}
function getEntryDescription(entry, doesSupportMarkdown, settings) {
  let result;
  if (doesSupportMarkdown) {
    result = {
      kind: "markdown",
      value: getEntryMarkdownDescription(entry, settings)
    };
  } else {
    result = {
      kind: "plaintext",
      value: getEntryStringDescription(entry, settings)
    };
  }
  if (result.value === "") {
    return void 0;
  }
  return result;
}
function textToMarkedString(text) {
  text = text.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
  return text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function getEntryStringDescription(entry, settings) {
  if (!entry.description || entry.description === "") {
    return "";
  }
  if (typeof entry.description !== "string") {
    return entry.description.value;
  }
  let result = "";
  if ((settings == null ? void 0 : settings.documentation) !== false) {
    if (entry.status) {
      result += getEntryStatus(entry.status);
    }
    result += entry.description;
    const browserLabel = getBrowserLabel(entry.browsers);
    if (browserLabel) {
      result += "\n(" + browserLabel + ")";
    }
    if ("syntax" in entry) {
      result += `

Syntax: ${entry.syntax}`;
    }
  }
  if (entry.references && entry.references.length > 0 && (settings == null ? void 0 : settings.references) !== false) {
    if (result.length > 0) {
      result += "\n\n";
    }
    result += entry.references.map((r) => {
      return `${r.name}: ${r.url}`;
    }).join(" | ");
  }
  return result;
}
function getEntryMarkdownDescription(entry, settings) {
  if (!entry.description || entry.description === "") {
    return "";
  }
  let result = "";
  if ((settings == null ? void 0 : settings.documentation) !== false) {
    if (entry.status) {
      result += getEntryStatus(entry.status);
    }
    if (typeof entry.description === "string") {
      result += textToMarkedString(entry.description);
    } else {
      result += entry.description.kind === MarkupKind.Markdown ? entry.description.value : textToMarkedString(entry.description.value);
    }
    const browserLabel = getBrowserLabel(entry.browsers);
    if (browserLabel) {
      result += "\n\n(" + textToMarkedString(browserLabel) + ")";
    }
    if ("syntax" in entry && entry.syntax) {
      result += `

Syntax: ${textToMarkedString(entry.syntax)}`;
    }
  }
  if (entry.references && entry.references.length > 0 && (settings == null ? void 0 : settings.references) !== false) {
    if (result.length > 0) {
      result += "\n\n";
    }
    result += entry.references.map((r) => {
      return `[${r.name}](${r.url})`;
    }).join(" | ");
  }
  return result;
}
function getBrowserLabel(browsers = []) {
  if (browsers.length === 0) {
    return null;
  }
  return browsers.map((b) => {
    let result = "";
    const matches2 = b.match(/([A-Z]+)(\d+)?/);
    const name = matches2[1];
    const version = matches2[2];
    if (name in browserNames) {
      result += browserNames[name];
    }
    if (version) {
      result += " " + version;
    }
    return result;
  }).join(", ");
}

// src/vscode-css-languageservice/languageFacts/colors.ts
import * as nls from "vscode-nls";
var localize = nls.loadMessageBundle();
var colorFunctions = [
  { func: "rgb($red, $green, $blue)", desc: localize("css.builtin.rgb", "Creates a Color from red, green, and blue values.") },
  { func: "rgba($red, $green, $blue, $alpha)", desc: localize("css.builtin.rgba", "Creates a Color from red, green, blue, and alpha values.") },
  { func: "hsl($hue, $saturation, $lightness)", desc: localize("css.builtin.hsl", "Creates a Color from hue, saturation, and lightness values.") },
  { func: "hsla($hue, $saturation, $lightness, $alpha)", desc: localize("css.builtin.hsla", "Creates a Color from hue, saturation, lightness, and alpha values.") },
  { func: "hwb($hue $white $black)", desc: localize("css.builtin.hwb", "Creates a Color from hue, white and black.") }
];
var colors = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgrey: "#a9a9a9",
  darkgreen: "#006400",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gray: "#808080",
  grey: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavender: "#e6e6fa",
  lavenderblush: "#fff0f5",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgrey: "#d3d3d3",
  lightgreen: "#90ee90",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370d8",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#d87093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  red: "#ff0000",
  rebeccapurple: "#663399",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
var colorKeywords = {
  "currentColor": "The value of the 'color' property. The computed value of the 'currentColor' keyword is the computed value of the 'color' property. If the 'currentColor' keyword is set on the 'color' property itself, it is treated as 'color:inherit' at parse time.",
  "transparent": "Fully transparent. This keyword can be considered a shorthand for rgba(0,0,0,0) which is its computed value."
};
function getNumericValue(node, factor) {
  const val = node.getText();
  const m = val.match(/^([-+]?[0-9]*\.?[0-9]+)(%?)$/);
  if (m) {
    if (m[2]) {
      factor = 100;
    }
    const result = parseFloat(m[1]) / factor;
    if (result >= 0 && result <= 1) {
      return result;
    }
  }
  throw new Error();
}
function getAngle(node) {
  const val = node.getText();
  const m = val.match(/^([-+]?[0-9]*\.?[0-9]+)(deg|rad|grad|turn)?$/);
  if (m) {
    switch (m[2]) {
      case "deg":
        return parseFloat(val) % 360;
      case "rad":
        return parseFloat(val) * 180 / Math.PI % 360;
      case "grad":
        return parseFloat(val) * 0.9 % 360;
      case "turn":
        return parseFloat(val) * 360 % 360;
      default:
        if ("undefined" === typeof m[2]) {
          return parseFloat(val) % 360;
        }
    }
  }
  throw new Error();
}
function isColorConstructor(node) {
  const name = node.getName();
  if (!name) {
    return false;
  }
  return /^(rgb|rgba|hsl|hsla|hwb)$/gi.test(name);
}
var Digit0 = 48;
var Digit9 = 57;
var A = 65;
var a = 97;
var f = 102;
function hexDigit(charCode) {
  if (charCode < Digit0) {
    return 0;
  }
  if (charCode <= Digit9) {
    return charCode - Digit0;
  }
  if (charCode < a) {
    charCode += a - A;
  }
  if (charCode >= a && charCode <= f) {
    return charCode - a + 10;
  }
  return 0;
}
function colorFromHex(text) {
  if (text[0] !== "#") {
    return null;
  }
  switch (text.length) {
    case 4:
      return {
        red: hexDigit(text.charCodeAt(1)) * 17 / 255,
        green: hexDigit(text.charCodeAt(2)) * 17 / 255,
        blue: hexDigit(text.charCodeAt(3)) * 17 / 255,
        alpha: 1
      };
    case 5:
      return {
        red: hexDigit(text.charCodeAt(1)) * 17 / 255,
        green: hexDigit(text.charCodeAt(2)) * 17 / 255,
        blue: hexDigit(text.charCodeAt(3)) * 17 / 255,
        alpha: hexDigit(text.charCodeAt(4)) * 17 / 255
      };
    case 7:
      return {
        red: (hexDigit(text.charCodeAt(1)) * 16 + hexDigit(text.charCodeAt(2))) / 255,
        green: (hexDigit(text.charCodeAt(3)) * 16 + hexDigit(text.charCodeAt(4))) / 255,
        blue: (hexDigit(text.charCodeAt(5)) * 16 + hexDigit(text.charCodeAt(6))) / 255,
        alpha: 1
      };
    case 9:
      return {
        red: (hexDigit(text.charCodeAt(1)) * 16 + hexDigit(text.charCodeAt(2))) / 255,
        green: (hexDigit(text.charCodeAt(3)) * 16 + hexDigit(text.charCodeAt(4))) / 255,
        blue: (hexDigit(text.charCodeAt(5)) * 16 + hexDigit(text.charCodeAt(6))) / 255,
        alpha: (hexDigit(text.charCodeAt(7)) * 16 + hexDigit(text.charCodeAt(8))) / 255
      };
  }
  return null;
}
function colorFromHSL(hue, sat, light, alpha = 1) {
  hue = hue / 60;
  if (sat === 0) {
    return { red: light, green: light, blue: light, alpha };
  } else {
    const hueToRgb = (t12, t22, hue2) => {
      while (hue2 < 0) {
        hue2 += 6;
      }
      while (hue2 >= 6) {
        hue2 -= 6;
      }
      if (hue2 < 1) {
        return (t22 - t12) * hue2 + t12;
      }
      if (hue2 < 3) {
        return t22;
      }
      if (hue2 < 4) {
        return (t22 - t12) * (4 - hue2) + t12;
      }
      return t12;
    };
    const t2 = light <= 0.5 ? light * (sat + 1) : light + sat - light * sat;
    const t1 = light * 2 - t2;
    return { red: hueToRgb(t1, t2, hue + 2), green: hueToRgb(t1, t2, hue), blue: hueToRgb(t1, t2, hue - 2), alpha };
  }
}
function hslFromColor(rgba) {
  const r = rgba.red;
  const g = rgba.green;
  const b = rgba.blue;
  const a2 = rgba.alpha;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h = 0;
  let s = 0;
  const l = (min + max) / 2;
  const chroma = max - min;
  if (chroma > 0) {
    s = Math.min(l <= 0.5 ? chroma / (2 * l) : chroma / (2 - 2 * l), 1);
    switch (max) {
      case r:
        h = (g - b) / chroma + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / chroma + 2;
        break;
      case b:
        h = (r - g) / chroma + 4;
        break;
    }
    h *= 60;
    h = Math.round(h);
  }
  return { h, s, l, a: a2 };
}
function colorFromHWB(hue, white, black, alpha = 1) {
  if (white + black >= 1) {
    const gray = white / (white + black);
    return { red: gray, green: gray, blue: gray, alpha };
  }
  const rgb = colorFromHSL(hue, 1, 0.5, alpha);
  let red = rgb.red;
  red *= 1 - white - black;
  red += white;
  let green = rgb.green;
  green *= 1 - white - black;
  green += white;
  let blue = rgb.blue;
  blue *= 1 - white - black;
  blue += white;
  return {
    red,
    green,
    blue,
    alpha
  };
}
function hwbFromColor(rgba) {
  const hsl = hslFromColor(rgba);
  const white = Math.min(rgba.red, rgba.green, rgba.blue);
  const black = 1 - Math.max(rgba.red, rgba.green, rgba.blue);
  return {
    h: hsl.h,
    w: white,
    b: black,
    a: hsl.a
  };
}
function getColorValue(node) {
  if (node.type === 32 /* HexColorValue */) {
    const text = node.getText();
    return colorFromHex(text);
  } else if (node.type === 30 /* Function */) {
    const functionNode = node;
    const name = functionNode.getName();
    let colorValues = functionNode.getArguments().getChildren();
    if (colorValues.length === 1) {
      const functionArg = colorValues[0].getChildren();
      if (functionArg.length === 1 && functionArg[0].type === 22 /* Expression */) {
        colorValues = functionArg[0].getChildren();
        if (colorValues.length === 3) {
          const lastValue = colorValues[2];
          if (lastValue instanceof BinaryExpression) {
            const left = lastValue.getLeft(), right = lastValue.getRight(), operator = lastValue.getOperator();
            if (left && right && operator && operator.matches("/")) {
              colorValues = [colorValues[0], colorValues[1], left, right];
            }
          }
        }
      }
    }
    if (!name || colorValues.length < 3 || colorValues.length > 4) {
      return null;
    }
    try {
      const alpha = colorValues.length === 4 ? getNumericValue(colorValues[3], 1) : 1;
      if (name === "rgb" || name === "rgba") {
        return {
          red: getNumericValue(colorValues[0], 255),
          green: getNumericValue(colorValues[1], 255),
          blue: getNumericValue(colorValues[2], 255),
          alpha
        };
      } else if (name === "hsl" || name === "hsla") {
        const h = getAngle(colorValues[0]);
        const s = getNumericValue(colorValues[1], 100);
        const l = getNumericValue(colorValues[2], 100);
        return colorFromHSL(h, s, l, alpha);
      } else if (name === "hwb") {
        const h = getAngle(colorValues[0]);
        const w = getNumericValue(colorValues[1], 100);
        const b = getNumericValue(colorValues[2], 100);
        return colorFromHWB(h, w, b, alpha);
      }
    } catch (e) {
      return null;
    }
  } else if (node.type === 1 /* Identifier */) {
    if (node.parent && node.parent.type !== 24 /* Term */) {
      return null;
    }
    const term = node.parent;
    if (term && term.parent && term.parent.type === 23 /* BinaryExpression */) {
      const expression = term.parent;
      if (expression.parent && expression.parent.type === 70 /* ListEntry */ && expression.parent.key === expression) {
        return null;
      }
    }
    const candidateColor = node.getText().toLowerCase();
    if (candidateColor === "none") {
      return null;
    }
    const colorHex = colors[candidateColor];
    if (colorHex) {
      return colorFromHex(colorHex);
    }
  }
  return null;
}

// src/vscode-css-languageservice/languageFacts/builtinData.ts
var positionKeywords = {
  "bottom": "Computes to \u2018100%\u2019 for the vertical position if one or two values are given, otherwise specifies the bottom edge as the origin for the next offset.",
  "center": "Computes to \u201850%\u2019 (\u2018left 50%\u2019) for the horizontal position if the horizontal position is not otherwise specified, or \u201850%\u2019 (\u2018top 50%\u2019) for the vertical position if it is.",
  "left": "Computes to \u20180%\u2019 for the horizontal position if one or two values are given, otherwise specifies the left edge as the origin for the next offset.",
  "right": "Computes to \u2018100%\u2019 for the horizontal position if one or two values are given, otherwise specifies the right edge as the origin for the next offset.",
  "top": "Computes to \u20180%\u2019 for the vertical position if one or two values are given, otherwise specifies the top edge as the origin for the next offset."
};
var repeatStyleKeywords = {
  "no-repeat": "Placed once and not repeated in this direction.",
  "repeat": "Repeated in this direction as often as needed to cover the background painting area.",
  "repeat-x": "Computes to \u2018repeat no-repeat\u2019.",
  "repeat-y": "Computes to \u2018no-repeat repeat\u2019.",
  "round": "Repeated as often as will fit within the background positioning area. If it doesn\u2019t fit a whole number of times, it is rescaled so that it does.",
  "space": "Repeated as often as will fit within the background positioning area without being clipped and then the images are spaced out to fill the area."
};
var lineStyleKeywords = {
  "dashed": "A series of square-ended dashes.",
  "dotted": "A series of round dots.",
  "double": "Two parallel solid lines with some space between them.",
  "groove": "Looks as if it were carved in the canvas.",
  "hidden": "Same as \u2018none\u2019, but has different behavior in the border conflict resolution rules for border-collapsed tables.",
  "inset": "Looks as if the content on the inside of the border is sunken into the canvas.",
  "none": "No border. Color and width are ignored.",
  "outset": "Looks as if the content on the inside of the border is coming out of the canvas.",
  "ridge": "Looks as if it were coming out of the canvas.",
  "solid": "A single line segment."
};
var lineWidthKeywords = ["medium", "thick", "thin"];
var boxKeywords = {
  "border-box": "The background is painted within (clipped to) the border box.",
  "content-box": "The background is painted within (clipped to) the content box.",
  "padding-box": "The background is painted within (clipped to) the padding box."
};
var geometryBoxKeywords = {
  "margin-box": "Uses the margin box as reference box.",
  "fill-box": "Uses the object bounding box as reference box.",
  "stroke-box": "Uses the stroke bounding box as reference box.",
  "view-box": "Uses the nearest SVG viewport as reference box."
};
var cssWideKeywords = {
  "initial": "Represents the value specified as the property\u2019s initial value.",
  "inherit": "Represents the computed value of the property on the element\u2019s parent.",
  "unset": "Acts as either `inherit` or `initial`, depending on whether the property is inherited or not."
};
var cssWideFunctions = {
  "var()": "Evaluates the value of a custom variable.",
  "calc()": "Evaluates an mathematical expression. The following operators can be used: + - * /."
};
var imageFunctions = {
  "url()": "Reference an image file by URL",
  "image()": "Provide image fallbacks and annotations.",
  "-webkit-image-set()": "Provide multiple resolutions. Remember to use unprefixed image-set() in addition.",
  "image-set()": "Provide multiple resolutions of an image and const the UA decide which is most appropriate in a given situation.",
  "-moz-element()": "Use an element in the document as an image. Remember to use unprefixed element() in addition.",
  "element()": "Use an element in the document as an image.",
  "cross-fade()": "Indicates the two images to be combined and how far along in the transition the combination is.",
  "-webkit-gradient()": "Deprecated. Use modern linear-gradient() or radial-gradient() instead.",
  "-webkit-linear-gradient()": "Linear gradient. Remember to use unprefixed version in addition.",
  "-moz-linear-gradient()": "Linear gradient. Remember to use unprefixed version in addition.",
  "-o-linear-gradient()": "Linear gradient. Remember to use unprefixed version in addition.",
  "linear-gradient()": "A linear gradient is created by specifying a straight gradient line, and then several colors placed along that line.",
  "-webkit-repeating-linear-gradient()": "Repeating Linear gradient. Remember to use unprefixed version in addition.",
  "-moz-repeating-linear-gradient()": "Repeating Linear gradient. Remember to use unprefixed version in addition.",
  "-o-repeating-linear-gradient()": "Repeating Linear gradient. Remember to use unprefixed version in addition.",
  "repeating-linear-gradient()": "Same as linear-gradient, except the color-stops are repeated infinitely in both directions, with their positions shifted by multiples of the difference between the last specified color-stop\u2019s position and the first specified color-stop\u2019s position.",
  "-webkit-radial-gradient()": "Radial gradient. Remember to use unprefixed version in addition.",
  "-moz-radial-gradient()": "Radial gradient. Remember to use unprefixed version in addition.",
  "radial-gradient()": "Colors emerge from a single point and smoothly spread outward in a circular or elliptical shape.",
  "-webkit-repeating-radial-gradient()": "Repeating radial gradient. Remember to use unprefixed version in addition.",
  "-moz-repeating-radial-gradient()": "Repeating radial gradient. Remember to use unprefixed version in addition.",
  "repeating-radial-gradient()": "Same as radial-gradient, except the color-stops are repeated infinitely in both directions, with their positions shifted by multiples of the difference between the last specified color-stop\u2019s position and the first specified color-stop\u2019s position."
};
var transitionTimingFunctions = {
  "ease": "Equivalent to cubic-bezier(0.25, 0.1, 0.25, 1.0).",
  "ease-in": "Equivalent to cubic-bezier(0.42, 0, 1.0, 1.0).",
  "ease-in-out": "Equivalent to cubic-bezier(0.42, 0, 0.58, 1.0).",
  "ease-out": "Equivalent to cubic-bezier(0, 0, 0.58, 1.0).",
  "linear": "Equivalent to cubic-bezier(0.0, 0.0, 1.0, 1.0).",
  "step-end": "Equivalent to steps(1, end).",
  "step-start": "Equivalent to steps(1, start).",
  "steps()": "The first parameter specifies the number of intervals in the function. The second parameter, which is optional, is either the value \u201Cstart\u201D or \u201Cend\u201D.",
  "cubic-bezier()": "Specifies a cubic-bezier curve. The four values specify points P1 and P2  of the curve as (x1, y1, x2, y2).",
  "cubic-bezier(0.6, -0.28, 0.735, 0.045)": "Ease-in Back. Overshoots.",
  "cubic-bezier(0.68, -0.55, 0.265, 1.55)": "Ease-in-out Back. Overshoots.",
  "cubic-bezier(0.175, 0.885, 0.32, 1.275)": "Ease-out Back. Overshoots.",
  "cubic-bezier(0.6, 0.04, 0.98, 0.335)": "Ease-in Circular. Based on half circle.",
  "cubic-bezier(0.785, 0.135, 0.15, 0.86)": "Ease-in-out Circular. Based on half circle.",
  "cubic-bezier(0.075, 0.82, 0.165, 1)": "Ease-out Circular. Based on half circle.",
  "cubic-bezier(0.55, 0.055, 0.675, 0.19)": "Ease-in Cubic. Based on power of three.",
  "cubic-bezier(0.645, 0.045, 0.355, 1)": "Ease-in-out Cubic. Based on power of three.",
  "cubic-bezier(0.215, 0.610, 0.355, 1)": "Ease-out Cubic. Based on power of three.",
  "cubic-bezier(0.95, 0.05, 0.795, 0.035)": "Ease-in Exponential. Based on two to the power ten.",
  "cubic-bezier(1, 0, 0, 1)": "Ease-in-out Exponential. Based on two to the power ten.",
  "cubic-bezier(0.19, 1, 0.22, 1)": "Ease-out Exponential. Based on two to the power ten.",
  "cubic-bezier(0.47, 0, 0.745, 0.715)": "Ease-in Sine.",
  "cubic-bezier(0.445, 0.05, 0.55, 0.95)": "Ease-in-out Sine.",
  "cubic-bezier(0.39, 0.575, 0.565, 1)": "Ease-out Sine.",
  "cubic-bezier(0.55, 0.085, 0.68, 0.53)": "Ease-in Quadratic. Based on power of two.",
  "cubic-bezier(0.455, 0.03, 0.515, 0.955)": "Ease-in-out Quadratic. Based on power of two.",
  "cubic-bezier(0.25, 0.46, 0.45, 0.94)": "Ease-out Quadratic. Based on power of two.",
  "cubic-bezier(0.895, 0.03, 0.685, 0.22)": "Ease-in Quartic. Based on power of four.",
  "cubic-bezier(0.77, 0, 0.175, 1)": "Ease-in-out Quartic. Based on power of four.",
  "cubic-bezier(0.165, 0.84, 0.44, 1)": "Ease-out Quartic. Based on power of four.",
  "cubic-bezier(0.755, 0.05, 0.855, 0.06)": "Ease-in Quintic. Based on power of five.",
  "cubic-bezier(0.86, 0, 0.07, 1)": "Ease-in-out Quintic. Based on power of five.",
  "cubic-bezier(0.23, 1, 0.320, 1)": "Ease-out Quintic. Based on power of five."
};
var basicShapeFunctions = {
  "circle()": "Defines a circle.",
  "ellipse()": "Defines an ellipse.",
  "inset()": "Defines an inset rectangle.",
  "polygon()": "Defines a polygon."
};
var units = {
  "length": ["em", "rem", "ex", "px", "cm", "mm", "in", "pt", "pc", "ch", "vw", "vh", "vmin", "vmax"],
  "angle": ["deg", "rad", "grad", "turn"],
  "time": ["ms", "s"],
  "frequency": ["Hz", "kHz"],
  "resolution": ["dpi", "dpcm", "dppx"],
  "percentage": ["%", "fr"]
};
var html5Tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rb",
  "rp",
  "rt",
  "rtc",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "const",
  "video",
  "wbr"
];
var svgElements = [
  "circle",
  "clipPath",
  "cursor",
  "defs",
  "desc",
  "ellipse",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "filter",
  "foreignObject",
  "g",
  "hatch",
  "hatchpath",
  "image",
  "line",
  "linearGradient",
  "marker",
  "mask",
  "mesh",
  "meshpatch",
  "meshrow",
  "metadata",
  "mpath",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "set",
  "solidcolor",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "textPath",
  "tspan",
  "use",
  "view"
];
var pageBoxDirectives = [
  "@bottom-center",
  "@bottom-left",
  "@bottom-left-corner",
  "@bottom-right",
  "@bottom-right-corner",
  "@left-bottom",
  "@left-middle",
  "@left-top",
  "@right-bottom",
  "@right-middle",
  "@right-top",
  "@top-center",
  "@top-left",
  "@top-left-corner",
  "@top-right",
  "@top-right-corner"
];

// src/vscode-css-languageservice/parser/cssScanner.ts
var MultiLineStream = class {
  constructor(source) {
    this.source = source;
    this.len = source.length;
    this.position = 0;
  }
  substring(from, to = this.position) {
    return this.source.substring(from, to);
  }
  eos() {
    return this.len <= this.position;
  }
  pos() {
    return this.position;
  }
  goBackTo(pos) {
    this.position = pos;
  }
  goBack(n) {
    this.position -= n;
  }
  advance(n) {
    this.position += n;
  }
  nextChar() {
    return this.source.charCodeAt(this.position++) || 0;
  }
  peekChar(n = 0) {
    return this.source.charCodeAt(this.position + n) || 0;
  }
  lookbackChar(n = 0) {
    return this.source.charCodeAt(this.position - n) || 0;
  }
  advanceIfChar(ch) {
    if (ch === this.source.charCodeAt(this.position)) {
      this.position++;
      return true;
    }
    return false;
  }
  advanceIfChars(ch) {
    if (this.position + ch.length > this.source.length) {
      return false;
    }
    let i = 0;
    for (; i < ch.length; i++) {
      if (this.source.charCodeAt(this.position + i) !== ch[i]) {
        return false;
      }
    }
    this.advance(i);
    return true;
  }
  advanceWhileChar(condition) {
    const posNow = this.position;
    while (this.position < this.len && condition(this.source.charCodeAt(this.position))) {
      this.position++;
    }
    return this.position - posNow;
  }
};
var _a = "a".charCodeAt(0);
var _f = "f".charCodeAt(0);
var _z = "z".charCodeAt(0);
var _u = "u".charCodeAt(0);
var _A = "A".charCodeAt(0);
var _F = "F".charCodeAt(0);
var _Z = "Z".charCodeAt(0);
var _02 = "0".charCodeAt(0);
var _92 = "9".charCodeAt(0);
var _TLD = "~".charCodeAt(0);
var _HAT = "^".charCodeAt(0);
var _EQS = "=".charCodeAt(0);
var _PIP = "|".charCodeAt(0);
var _MIN = "-".charCodeAt(0);
var _USC = "_".charCodeAt(0);
var _PRC = "%".charCodeAt(0);
var _MUL = "*".charCodeAt(0);
var _LPA = "(".charCodeAt(0);
var _RPA = ")".charCodeAt(0);
var _LAN = "<".charCodeAt(0);
var _RAN = ">".charCodeAt(0);
var _ATS = "@".charCodeAt(0);
var _HSH = "#".charCodeAt(0);
var _DLR = "$".charCodeAt(0);
var _BSL = "\\".charCodeAt(0);
var _FSL = "/".charCodeAt(0);
var _NWL = "\n".charCodeAt(0);
var _CAR = "\r".charCodeAt(0);
var _LFD = "\f".charCodeAt(0);
var _DQO = '"'.charCodeAt(0);
var _SQO = "'".charCodeAt(0);
var _WSP = " ".charCodeAt(0);
var _TAB = "	".charCodeAt(0);
var _SEM = ";".charCodeAt(0);
var _COL = ":".charCodeAt(0);
var _CUL = "{".charCodeAt(0);
var _CUR = "}".charCodeAt(0);
var _BRL = "[".charCodeAt(0);
var _BRR = "]".charCodeAt(0);
var _CMA = ",".charCodeAt(0);
var _DOT = ".".charCodeAt(0);
var _BNG = "!".charCodeAt(0);
var _QSM = "?".charCodeAt(0);
var _PLS = "+".charCodeAt(0);
var staticTokenTable = {};
staticTokenTable[_SEM] = 13 /* SemiColon */;
staticTokenTable[_COL] = 12 /* Colon */;
staticTokenTable[_CUL] = 14 /* CurlyL */;
staticTokenTable[_CUR] = 15 /* CurlyR */;
staticTokenTable[_BRR] = 19 /* BracketR */;
staticTokenTable[_BRL] = 18 /* BracketL */;
staticTokenTable[_LPA] = 16 /* ParenthesisL */;
staticTokenTable[_RPA] = 17 /* ParenthesisR */;
staticTokenTable[_CMA] = 35 /* Comma */;
var staticUnitTable = {};
staticUnitTable["em"] = 27 /* EMS */;
staticUnitTable["ex"] = 28 /* EXS */;
staticUnitTable["px"] = 29 /* Length */;
staticUnitTable["cm"] = 29 /* Length */;
staticUnitTable["mm"] = 29 /* Length */;
staticUnitTable["in"] = 29 /* Length */;
staticUnitTable["pt"] = 29 /* Length */;
staticUnitTable["pc"] = 29 /* Length */;
staticUnitTable["deg"] = 30 /* Angle */;
staticUnitTable["rad"] = 30 /* Angle */;
staticUnitTable["grad"] = 30 /* Angle */;
staticUnitTable["ms"] = 31 /* Time */;
staticUnitTable["s"] = 31 /* Time */;
staticUnitTable["hz"] = 32 /* Freq */;
staticUnitTable["khz"] = 32 /* Freq */;
staticUnitTable["%"] = 7 /* Percentage */;
staticUnitTable["fr"] = 7 /* Percentage */;
staticUnitTable["dpi"] = 34 /* Resolution */;
staticUnitTable["dpcm"] = 34 /* Resolution */;
var Scanner = class {
  constructor() {
    this.stream = new MultiLineStream("");
    this.ignoreComment = true;
    this.ignoreWhitespace = true;
    this.inURL = false;
  }
  setSource(input) {
    this.stream = new MultiLineStream(input);
  }
  finishToken(offset, type, text) {
    return {
      offset,
      len: this.stream.pos() - offset,
      type,
      text: text || this.stream.substring(offset)
    };
  }
  substring(offset, len) {
    return this.stream.substring(offset, offset + len);
  }
  pos() {
    return this.stream.pos();
  }
  goBackTo(pos) {
    this.stream.goBackTo(pos);
  }
  scanUnquotedString() {
    const offset = this.stream.pos();
    const content = [];
    if (this._unquotedString(content)) {
      return this.finishToken(offset, 4 /* UnquotedString */, content.join(""));
    }
    return null;
  }
  scan() {
    const triviaToken = this.trivia();
    if (triviaToken !== null) {
      return triviaToken;
    }
    const offset = this.stream.pos();
    if (this.stream.eos()) {
      return this.finishToken(offset, 41 /* EOF */);
    }
    return this.scanNext(offset);
  }
  tryScanUnicode() {
    const offset = this.stream.pos();
    if (!this.stream.eos() && this._unicodeRange()) {
      return this.finishToken(offset, 9 /* UnicodeRange */);
    }
    this.stream.goBackTo(offset);
    return void 0;
  }
  scanNext(offset) {
    if (this.stream.advanceIfChars([_LAN, _BNG, _MIN, _MIN])) {
      return this.finishToken(offset, 10 /* CDO */);
    }
    if (this.stream.advanceIfChars([_MIN, _MIN, _RAN])) {
      return this.finishToken(offset, 11 /* CDC */);
    }
    let content = [];
    if (this.ident(content)) {
      return this.finishToken(offset, 0 /* Ident */, content.join(""));
    }
    if (this.stream.advanceIfChar(_ATS)) {
      content = ["@"];
      if (this._name(content)) {
        const keywordText = content.join("");
        if (keywordText === "@charset") {
          return this.finishToken(offset, 36 /* Charset */, keywordText);
        }
        return this.finishToken(offset, 1 /* AtKeyword */, keywordText);
      } else {
        return this.finishToken(offset, 26 /* Delim */);
      }
    }
    if (this.stream.advanceIfChar(_HSH)) {
      content = ["#"];
      if (this._name(content)) {
        return this.finishToken(offset, 5 /* Hash */, content.join(""));
      } else {
        return this.finishToken(offset, 26 /* Delim */);
      }
    }
    if (this.stream.advanceIfChar(_BNG)) {
      return this.finishToken(offset, 33 /* Exclamation */);
    }
    if (this._number()) {
      const pos = this.stream.pos();
      content = [this.stream.substring(offset, pos)];
      if (this.stream.advanceIfChar(_PRC)) {
        return this.finishToken(offset, 7 /* Percentage */);
      } else if (this.ident(content)) {
        const dim = this.stream.substring(pos).toLowerCase();
        const tokenType2 = staticUnitTable[dim];
        if (typeof tokenType2 !== "undefined") {
          return this.finishToken(offset, tokenType2, content.join(""));
        } else {
          return this.finishToken(offset, 8 /* Dimension */, content.join(""));
        }
      }
      return this.finishToken(offset, 6 /* Num */);
    }
    content = [];
    let tokenType = this._string(content);
    if (tokenType !== null) {
      return this.finishToken(offset, tokenType, content.join(""));
    }
    tokenType = staticTokenTable[this.stream.peekChar()];
    if (typeof tokenType !== "undefined") {
      this.stream.advance(1);
      return this.finishToken(offset, tokenType);
    }
    if (this.stream.peekChar(0) === _TLD && this.stream.peekChar(1) === _EQS) {
      this.stream.advance(2);
      return this.finishToken(offset, 21 /* Includes */);
    }
    if (this.stream.peekChar(0) === _PIP && this.stream.peekChar(1) === _EQS) {
      this.stream.advance(2);
      return this.finishToken(offset, 22 /* Dashmatch */);
    }
    if (this.stream.peekChar(0) === _MUL && this.stream.peekChar(1) === _EQS) {
      this.stream.advance(2);
      return this.finishToken(offset, 23 /* SubstringOperator */);
    }
    if (this.stream.peekChar(0) === _HAT && this.stream.peekChar(1) === _EQS) {
      this.stream.advance(2);
      return this.finishToken(offset, 24 /* PrefixOperator */);
    }
    if (this.stream.peekChar(0) === _DLR && this.stream.peekChar(1) === _EQS) {
      this.stream.advance(2);
      return this.finishToken(offset, 25 /* SuffixOperator */);
    }
    this.stream.nextChar();
    return this.finishToken(offset, 26 /* Delim */);
  }
  trivia() {
    while (true) {
      const offset = this.stream.pos();
      if (this._whitespace()) {
        if (!this.ignoreWhitespace) {
          return this.finishToken(offset, 20 /* Whitespace */);
        }
      } else if (this.comment()) {
        if (!this.ignoreComment) {
          return this.finishToken(offset, 39 /* Comment */);
        }
      } else {
        return null;
      }
    }
  }
  comment() {
    if (this.stream.advanceIfChars([_FSL, _MUL])) {
      let success = false, hot = false;
      this.stream.advanceWhileChar((ch) => {
        if (hot && ch === _FSL) {
          success = true;
          return false;
        }
        hot = ch === _MUL;
        return true;
      });
      if (success) {
        this.stream.advance(1);
      }
      return true;
    }
    return false;
  }
  _number() {
    let npeek = 0, ch;
    if (this.stream.peekChar() === _DOT) {
      npeek = 1;
    }
    ch = this.stream.peekChar(npeek);
    if (ch >= _02 && ch <= _92) {
      this.stream.advance(npeek + 1);
      this.stream.advanceWhileChar((ch2) => {
        return ch2 >= _02 && ch2 <= _92 || npeek === 0 && ch2 === _DOT;
      });
      return true;
    }
    return false;
  }
  _newline(result) {
    const ch = this.stream.peekChar();
    switch (ch) {
      case _CAR:
      case _LFD:
      case _NWL:
        this.stream.advance(1);
        result.push(String.fromCharCode(ch));
        if (ch === _CAR && this.stream.advanceIfChar(_NWL)) {
          result.push("\n");
        }
        return true;
    }
    return false;
  }
  _escape(result, includeNewLines) {
    let ch = this.stream.peekChar();
    if (ch === _BSL) {
      this.stream.advance(1);
      ch = this.stream.peekChar();
      let hexNumCount = 0;
      while (hexNumCount < 6 && (ch >= _02 && ch <= _92 || ch >= _a && ch <= _f || ch >= _A && ch <= _F)) {
        this.stream.advance(1);
        ch = this.stream.peekChar();
        hexNumCount++;
      }
      if (hexNumCount > 0) {
        try {
          const hexVal = parseInt(this.stream.substring(this.stream.pos() - hexNumCount), 16);
          if (hexVal) {
            result.push(String.fromCharCode(hexVal));
          }
        } catch (e) {
        }
        if (ch === _WSP || ch === _TAB) {
          this.stream.advance(1);
        } else {
          this._newline([]);
        }
        return true;
      }
      if (ch !== _CAR && ch !== _LFD && ch !== _NWL) {
        this.stream.advance(1);
        result.push(String.fromCharCode(ch));
        return true;
      } else if (includeNewLines) {
        return this._newline(result);
      }
    }
    return false;
  }
  _stringChar(closeQuote, result) {
    const ch = this.stream.peekChar();
    if (ch !== 0 && ch !== closeQuote && ch !== _BSL && ch !== _CAR && ch !== _LFD && ch !== _NWL) {
      this.stream.advance(1);
      result.push(String.fromCharCode(ch));
      return true;
    }
    return false;
  }
  _string(result) {
    if (this.stream.peekChar() === _SQO || this.stream.peekChar() === _DQO) {
      const closeQuote = this.stream.nextChar();
      result.push(String.fromCharCode(closeQuote));
      while (this._stringChar(closeQuote, result) || this._escape(result, true)) {
      }
      if (this.stream.peekChar() === closeQuote) {
        this.stream.nextChar();
        result.push(String.fromCharCode(closeQuote));
        return 2 /* String */;
      } else {
        return 3 /* BadString */;
      }
    }
    return null;
  }
  _unquotedChar(result) {
    const ch = this.stream.peekChar();
    if (ch !== 0 && ch !== _BSL && ch !== _SQO && ch !== _DQO && ch !== _LPA && ch !== _RPA && ch !== _WSP && ch !== _TAB && ch !== _NWL && ch !== _LFD && ch !== _CAR) {
      this.stream.advance(1);
      result.push(String.fromCharCode(ch));
      return true;
    }
    return false;
  }
  _unquotedString(result) {
    let hasContent = false;
    while (this._unquotedChar(result) || this._escape(result)) {
      hasContent = true;
    }
    return hasContent;
  }
  _whitespace() {
    const n = this.stream.advanceWhileChar((ch) => {
      return ch === _WSP || ch === _TAB || ch === _NWL || ch === _LFD || ch === _CAR;
    });
    return n > 0;
  }
  _name(result) {
    let matched = false;
    while (this._identChar(result) || this._escape(result)) {
      matched = true;
    }
    return matched;
  }
  ident(result) {
    const pos = this.stream.pos();
    const hasMinus = this._minus(result);
    if (hasMinus) {
      if (this._minus(result) || this._identFirstChar(result) || this._escape(result)) {
        while (this._identChar(result) || this._escape(result)) {
        }
        return true;
      }
    } else if (this._identFirstChar(result) || this._escape(result)) {
      while (this._identChar(result) || this._escape(result)) {
      }
      return true;
    }
    this.stream.goBackTo(pos);
    return false;
  }
  _identFirstChar(result) {
    const ch = this.stream.peekChar();
    if (ch === _USC || ch >= _a && ch <= _z || ch >= _A && ch <= _Z || ch >= 128 && ch <= 65535) {
      this.stream.advance(1);
      result.push(String.fromCharCode(ch));
      return true;
    }
    return false;
  }
  _minus(result) {
    const ch = this.stream.peekChar();
    if (ch === _MIN) {
      this.stream.advance(1);
      result.push(String.fromCharCode(ch));
      return true;
    }
    return false;
  }
  _identChar(result) {
    const ch = this.stream.peekChar();
    if (ch === _USC || ch === _MIN || ch >= _a && ch <= _z || ch >= _A && ch <= _Z || ch >= _02 && ch <= _92 || ch >= 128 && ch <= 65535) {
      this.stream.advance(1);
      result.push(String.fromCharCode(ch));
      return true;
    }
    return false;
  }
  _unicodeRange() {
    if (this.stream.advanceIfChar(_PLS)) {
      const isHexDigit = (ch) => ch >= _02 && ch <= _92 || ch >= _a && ch <= _f || ch >= _A && ch <= _F;
      const codePoints = this.stream.advanceWhileChar(isHexDigit) + this.stream.advanceWhileChar((ch) => ch === _QSM);
      if (codePoints >= 1 && codePoints <= 6) {
        if (this.stream.advanceIfChar(_MIN)) {
          const digits = this.stream.advanceWhileChar(isHexDigit);
          if (digits >= 1 && digits <= 6) {
            return true;
          }
        } else {
          return true;
        }
      }
    }
    return false;
  }
};

// src/vscode-css-languageservice/services/selectorPrinting.ts
import * as nls2 from "vscode-nls";
var localize2 = nls2.loadMessageBundle();
var Element = class {
  constructor() {
    this.parent = null;
    this.children = null;
    this.attributes = null;
  }
  findAttribute(name) {
    if (this.attributes) {
      for (const attribute of this.attributes) {
        if (attribute.name === name) {
          return attribute.value;
        }
      }
    }
    return null;
  }
  addChild(child) {
    if (child instanceof Element) {
      child.parent = this;
    }
    if (!this.children) {
      this.children = [];
    }
    this.children.push(child);
  }
  append(text) {
    if (this.attributes) {
      const last = this.attributes[this.attributes.length - 1];
      last.value = last.value + text;
    }
  }
  prepend(text) {
    if (this.attributes) {
      const first = this.attributes[0];
      first.value = text + first.value;
    }
  }
  findRoot() {
    let curr = this;
    while (curr.parent && !(curr.parent instanceof RootElement)) {
      curr = curr.parent;
    }
    return curr;
  }
  removeChild(child) {
    if (this.children) {
      const index = this.children.indexOf(child);
      if (index !== -1) {
        this.children.splice(index, 1);
        return true;
      }
    }
    return false;
  }
  addAttr(name, value) {
    if (!this.attributes) {
      this.attributes = [];
    }
    for (const attribute of this.attributes) {
      if (attribute.name === name) {
        attribute.value += " " + value;
        return;
      }
    }
    this.attributes.push({ name, value });
  }
  clone(cloneChildren = true) {
    const elem = new Element();
    if (this.attributes) {
      elem.attributes = [];
      for (const attribute of this.attributes) {
        elem.addAttr(attribute.name, attribute.value);
      }
    }
    if (cloneChildren && this.children) {
      elem.children = [];
      for (let index = 0; index < this.children.length; index++) {
        elem.addChild(this.children[index].clone());
      }
    }
    return elem;
  }
  cloneWithParent() {
    const clone = this.clone(false);
    if (this.parent && !(this.parent instanceof RootElement)) {
      const parentClone = this.parent.cloneWithParent();
      parentClone.addChild(clone);
    }
    return clone;
  }
};
var RootElement = class extends Element {
};
var LabelElement = class extends Element {
  constructor(label) {
    super();
    this.addAttr("name", label);
  }
};
var MarkedStringPrinter = class {
  constructor(quote) {
    this.quote = quote;
    this.result = [];
  }
  print(element) {
    this.result = [];
    if (element instanceof RootElement) {
      if (element.children) {
        this.doPrint(element.children, 0);
      }
    } else {
      this.doPrint([element], 0);
    }
    const value = this.result.join("\n");
    return [{ language: "html", value }];
  }
  doPrint(elements, indent) {
    for (const element of elements) {
      this.doPrintElement(element, indent);
      if (element.children) {
        this.doPrint(element.children, indent + 1);
      }
    }
  }
  writeLine(level, content) {
    const indent = new Array(level + 1).join("  ");
    this.result.push(indent + content);
  }
  doPrintElement(element, indent) {
    const name = element.findAttribute("name");
    if (element instanceof LabelElement || name === "\u2026") {
      this.writeLine(indent, name);
      return;
    }
    const content = ["<"];
    if (name) {
      content.push(name);
    } else {
      content.push("element");
    }
    if (element.attributes) {
      for (const attr of element.attributes) {
        if (attr.name !== "name") {
          content.push(" ");
          content.push(attr.name);
          const value = attr.value;
          if (value) {
            content.push("=");
            content.push(quotes.ensure(value, this.quote));
          }
        }
      }
    }
    content.push(">");
    this.writeLine(indent, content.join(""));
  }
};
var quotes;
((quotes2) => {
  function ensure(value, which) {
    return which + remove(value) + which;
  }
  quotes2.ensure = ensure;
  function remove(value) {
    const match = value.match(/^['"](.*)["']$/);
    if (match) {
      return match[1];
    }
    return value;
  }
  quotes2.remove = remove;
})(quotes || (quotes = {}));
var Specificity = class {
  constructor() {
    this.id = 0;
    this.attr = 0;
    this.tag = 0;
  }
};
function toElement(node, parentElement) {
  let result = new Element();
  for (const child of node.getChildren()) {
    switch (child.type) {
      case 7 /* SelectorCombinator */:
        if (parentElement) {
          const segments = child.getText().split("&");
          if (segments.length === 1) {
            result.addAttr("name", segments[0]);
            break;
          }
          result = parentElement.cloneWithParent();
          if (segments[0]) {
            const root = result.findRoot();
            root.prepend(segments[0]);
          }
          for (let i = 1; i < segments.length; i++) {
            if (i > 1) {
              const clone = parentElement.cloneWithParent();
              result.addChild(clone.findRoot());
              result = clone;
            }
            result.append(segments[i]);
          }
        }
        break;
      case 42 /* SelectorPlaceholder */:
        if (child.matches("@at-root")) {
          return result;
        }
      case 16 /* ElementNameSelector */:
        const text = child.getText();
        result.addAttr("name", text === "*" ? "element" : unescape(text));
        break;
      case 14 /* ClassSelector */:
        result.addAttr("class", unescape(child.getText().substring(1)));
        break;
      case 15 /* IdentifierSelector */:
        result.addAttr("id", unescape(child.getText().substring(1)));
        break;
      case 34 /* MixinDeclaration */:
        result.addAttr("class", child.getName());
        break;
      case 17 /* PseudoSelector */:
        result.addAttr(unescape(child.getText()), "");
        break;
      case 18 /* AttributeSelector */:
        const selector = child;
        const identifier = selector.getIdentifier();
        if (identifier) {
          const expression = selector.getValue();
          const operator = selector.getOperator();
          let value;
          if (expression && operator) {
            switch (unescape(operator.getText())) {
              case "|=":
                value = `${quotes.remove(unescape(expression.getText()))}-\u2026`;
                break;
              case "^=":
                value = `${quotes.remove(unescape(expression.getText()))}\u2026`;
                break;
              case "$=":
                value = `\u2026${quotes.remove(unescape(expression.getText()))}`;
                break;
              case "~=":
                value = ` \u2026 ${quotes.remove(unescape(expression.getText()))} \u2026 `;
                break;
              case "*=":
                value = `\u2026${quotes.remove(unescape(expression.getText()))}\u2026`;
                break;
              default:
                value = quotes.remove(unescape(expression.getText()));
                break;
            }
          }
          result.addAttr(unescape(identifier.getText()), value);
        }
        break;
    }
  }
  return result;
}
function unescape(content) {
  const scanner = new Scanner();
  scanner.setSource(content);
  const token = scanner.scanUnquotedString();
  if (token) {
    return token.text;
  }
  return content;
}
var SelectorPrinting = class {
  constructor(cssDataManager) {
    this.cssDataManager = cssDataManager;
  }
  selectorToMarkedString(node) {
    const root = selectorToElement(node);
    if (root) {
      const markedStrings = new MarkedStringPrinter('"').print(root);
      markedStrings.push(this.selectorToSpecificityMarkedString(node));
      return markedStrings;
    } else {
      return [];
    }
  }
  simpleSelectorToMarkedString(node) {
    const element = toElement(node);
    const markedStrings = new MarkedStringPrinter('"').print(element);
    markedStrings.push(this.selectorToSpecificityMarkedString(node));
    return markedStrings;
  }
  isPseudoElementIdentifier(text) {
    const match = text.match(/^::?([\w-]+)/);
    if (!match) {
      return false;
    }
    return !!this.cssDataManager.getPseudoElement("::" + match[1]);
  }
  selectorToSpecificityMarkedString(node) {
    const calculateScore = (node2) => {
      const specificity2 = new Specificity();
      elementLoop:
        for (const element of node2.getChildren()) {
          switch (element.type) {
            case 15 /* IdentifierSelector */:
              specificity2.id++;
              break;
            case 14 /* ClassSelector */:
            case 18 /* AttributeSelector */:
              specificity2.attr++;
              break;
            case 16 /* ElementNameSelector */:
              if (element.matches("*")) {
                break;
              }
              specificity2.tag++;
              break;
            case 17 /* PseudoSelector */:
              const text = element.getText();
              if (this.isPseudoElementIdentifier(text)) {
                specificity2.tag++;
                break;
              }
              if (text.match(/^:where/i)) {
                continue elementLoop;
              }
              if (text.match(/^:(not|has|is)/i) && element.getChildren().length > 0) {
                let mostSpecificListItem = new Specificity();
                for (const containerElement of element.getChildren()) {
                  let list;
                  if (containerElement.type === 0 /* Undefined */) {
                    list = containerElement.getChildren();
                  } else {
                    list = [containerElement];
                  }
                  for (const childElement of containerElement.getChildren()) {
                    const itemSpecificity = calculateScore(childElement);
                    if (itemSpecificity.id > mostSpecificListItem.id) {
                      mostSpecificListItem = itemSpecificity;
                      continue;
                    } else if (itemSpecificity.id < mostSpecificListItem.id) {
                      continue;
                    }
                    if (itemSpecificity.attr > mostSpecificListItem.attr) {
                      mostSpecificListItem = itemSpecificity;
                      continue;
                    } else if (itemSpecificity.attr < mostSpecificListItem.attr) {
                      continue;
                    }
                    if (itemSpecificity.tag > mostSpecificListItem.tag) {
                      mostSpecificListItem = itemSpecificity;
                      continue;
                    }
                  }
                }
                specificity2.id += mostSpecificListItem.id;
                specificity2.attr += mostSpecificListItem.attr;
                specificity2.tag += mostSpecificListItem.tag;
                continue elementLoop;
              }
              specificity2.attr++;
              break;
          }
          if (element.getChildren().length > 0) {
            const itemSpecificity = calculateScore(element);
            specificity2.id += itemSpecificity.id;
            specificity2.attr += itemSpecificity.attr;
            specificity2.tag += itemSpecificity.tag;
          }
        }
      return specificity2;
    };
    const specificity = calculateScore(node);
    return localize2("specificity", "[Selector Specificity](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity): ({0}, {1}, {2})", specificity.id, specificity.attr, specificity.tag);
  }
};
var SelectorElementBuilder = class {
  constructor(element) {
    this.prev = null;
    this.element = element;
  }
  processSelector(selector) {
    let parentElement = null;
    if (!(this.element instanceof RootElement)) {
      if (selector.getChildren().some((c) => c.hasChildren() && c.getChild(0).type === 7 /* SelectorCombinator */)) {
        const curr = this.element.findRoot();
        if (curr.parent instanceof RootElement) {
          parentElement = this.element;
          this.element = curr.parent;
          this.element.removeChild(curr);
          this.prev = null;
        }
      }
    }
    for (const selectorChild of selector.getChildren()) {
      if (selectorChild instanceof SimpleSelector) {
        if (this.prev instanceof SimpleSelector) {
          const labelElement = new LabelElement("\u2026");
          this.element.addChild(labelElement);
          this.element = labelElement;
        } else if (this.prev && (this.prev.matches("+") || this.prev.matches("~")) && this.element.parent) {
          this.element = this.element.parent;
        }
        if (this.prev && this.prev.matches("~")) {
          this.element.addChild(new LabelElement("\u22EE"));
        }
        const thisElement = toElement(selectorChild, parentElement);
        const root = thisElement.findRoot();
        this.element.addChild(root);
        this.element = thisElement;
      }
      if (selectorChild instanceof SimpleSelector || selectorChild.type === 8 /* SelectorCombinatorParent */ || selectorChild.type === 11 /* SelectorCombinatorShadowPiercingDescendant */ || selectorChild.type === 9 /* SelectorCombinatorSibling */ || selectorChild.type === 10 /* SelectorCombinatorAllSiblings */) {
        this.prev = selectorChild;
      }
    }
  }
};
function isNewSelectorContext(node) {
  switch (node.type) {
    case 34 /* MixinDeclaration */:
    case 2 /* Stylesheet */:
      return true;
  }
  return false;
}
function selectorToElement(node) {
  if (node.matches("@at-root")) {
    return null;
  }
  const root = new RootElement();
  const parentRuleSets = [];
  const ruleSet = node.getParent();
  if (ruleSet instanceof RuleSet) {
    let parent = ruleSet.getParent();
    while (parent && !isNewSelectorContext(parent)) {
      if (parent instanceof RuleSet) {
        if (parent.getSelectors().matches("@at-root")) {
          break;
        }
        parentRuleSets.push(parent);
      }
      parent = parent.getParent();
    }
  }
  const builder = new SelectorElementBuilder(root);
  for (let i = parentRuleSets.length - 1; i >= 0; i--) {
    const selector = parentRuleSets[i].getSelectors().getChild(0);
    if (selector) {
      builder.processSelector(selector);
    }
  }
  builder.processSelector(node);
  return root;
}

// src/vscode-css-languageservice/utils/objects.ts
function values(obj) {
  return Object.keys(obj).map((key) => obj[key]);
}
function isDefined(obj) {
  return typeof obj !== "undefined";
}

// src/vscode-css-languageservice/services/cssHover.ts
var CSSHover = class {
  constructor(clientCapabilities, cssDataManager) {
    this.clientCapabilities = clientCapabilities;
    this.cssDataManager = cssDataManager;
    this.selectorPrinting = new SelectorPrinting(cssDataManager);
  }
  configure(settings) {
    this.defaultSettings = settings;
  }
  doHover(document, position, stylesheet, settings = this.defaultSettings) {
    function getRange2(node) {
      return Range.create(document.positionAt(node.offset), document.positionAt(node.end));
    }
    const offset = document.offsetAt(position);
    const nodepath = getNodePath(stylesheet, offset);
    let hover = null;
    for (let i = 0; i < nodepath.length; i++) {
      const node = nodepath[i];
      if (node instanceof Selector) {
        hover = {
          contents: this.selectorPrinting.selectorToMarkedString(node),
          range: getRange2(node)
        };
        break;
      }
      if (node instanceof SimpleSelector) {
        if (!startsWith(node.getText(), "@")) {
          hover = {
            contents: this.selectorPrinting.simpleSelectorToMarkedString(node),
            range: getRange2(node)
          };
        }
        break;
      }
      if (node instanceof Declaration) {
        const propertyName = node.getFullPropertyName();
        const entry = this.cssDataManager.getProperty(propertyName);
        if (entry) {
          const contents = getEntryDescription(entry, this.doesSupportMarkdown(), settings);
          if (contents) {
            hover = {
              contents,
              range: getRange2(node)
            };
          } else {
            hover = null;
          }
        }
        continue;
      }
      if (node instanceof UnknownAtRule) {
        const atRuleName = node.getText();
        const entry = this.cssDataManager.getAtDirective(atRuleName);
        if (entry) {
          const contents = getEntryDescription(entry, this.doesSupportMarkdown(), settings);
          if (contents) {
            hover = {
              contents,
              range: getRange2(node)
            };
          } else {
            hover = null;
          }
        }
        continue;
      }
      if (node instanceof Node && node.type === 17 /* PseudoSelector */) {
        const selectorName = node.getText();
        const entry = selectorName.slice(0, 2) === "::" ? this.cssDataManager.getPseudoElement(selectorName) : this.cssDataManager.getPseudoClass(selectorName);
        if (entry) {
          const contents = getEntryDescription(entry, this.doesSupportMarkdown(), settings);
          if (contents) {
            hover = {
              contents,
              range: getRange2(node)
            };
          } else {
            hover = null;
          }
        }
        continue;
      }
    }
    if (hover) {
      hover.contents = this.convertContents(hover.contents);
    }
    return hover;
  }
  convertContents(contents) {
    if (!this.doesSupportMarkdown()) {
      if (typeof contents === "string") {
        return contents;
      } else if ("kind" in contents) {
        return {
          kind: "plaintext",
          value: contents.value
        };
      } else if (Array.isArray(contents)) {
        return contents.map((c) => {
          return typeof c === "string" ? c : c.value;
        });
      } else {
        return contents.value;
      }
    }
    return contents;
  }
  doesSupportMarkdown() {
    if (!isDefined(this.supportsMarkdown)) {
      if (!isDefined(this.clientCapabilities)) {
        this.supportsMarkdown = true;
        return this.supportsMarkdown;
      }
      const hover = this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.hover;
      this.supportsMarkdown = hover && hover.contentFormat && Array.isArray(hover.contentFormat) && hover.contentFormat.indexOf(MarkupKind.Markdown) !== -1;
    }
    return this.supportsMarkdown;
  }
};

// src/vscode-css-languageservice/services/lintRules.ts
import * as nls3 from "vscode-nls";
var localize3 = nls3.loadMessageBundle();
var Warning = 2 /* Warning */;
var Error2 = 4 /* Error */;
var Ignore = 1 /* Ignore */;
var Rule = class {
  constructor(id, message, defaultValue) {
    this.id = id;
    this.message = message;
    this.defaultValue = defaultValue;
  }
};
var Setting = class {
  constructor(id, message, defaultValue) {
    this.id = id;
    this.message = message;
    this.defaultValue = defaultValue;
  }
};
var Rules = {
  AllVendorPrefixes: new Rule("compatibleVendorPrefixes", localize3("rule.vendorprefixes.all", "When using a vendor-specific prefix make sure to also include all other vendor-specific properties"), Ignore),
  IncludeStandardPropertyWhenUsingVendorPrefix: new Rule("vendorPrefix", localize3("rule.standardvendorprefix.all", "When using a vendor-specific prefix also include the standard property"), Warning),
  DuplicateDeclarations: new Rule("duplicateProperties", localize3("rule.duplicateDeclarations", "Do not use duplicate style definitions"), Ignore),
  EmptyRuleSet: new Rule("emptyRules", localize3("rule.emptyRuleSets", "Do not use empty rulesets"), Warning),
  ImportStatemement: new Rule("importStatement", localize3("rule.importDirective", "Import statements do not load in parallel"), Ignore),
  BewareOfBoxModelSize: new Rule("boxModel", localize3("rule.bewareOfBoxModelSize", "Do not use width or height when using padding or border"), Ignore),
  UniversalSelector: new Rule("universalSelector", localize3("rule.universalSelector", "The universal selector (*) is known to be slow"), Ignore),
  ZeroWithUnit: new Rule("zeroUnits", localize3("rule.zeroWidthUnit", "No unit for zero needed"), Ignore),
  RequiredPropertiesForFontFace: new Rule("fontFaceProperties", localize3("rule.fontFaceProperties", "@font-face rule must define 'src' and 'font-family' properties"), Warning),
  HexColorLength: new Rule("hexColorLength", localize3("rule.hexColor", "Hex colors must consist of three, four, six or eight hex numbers"), Error2),
  ArgsInColorFunction: new Rule("argumentsInColorFunction", localize3("rule.colorFunction", "Invalid number of parameters"), Error2),
  UnknownProperty: new Rule("unknownProperties", localize3("rule.unknownProperty", "Unknown property."), Warning),
  UnknownAtRules: new Rule("unknownAtRules", localize3("rule.unknownAtRules", "Unknown at-rule."), Warning),
  IEStarHack: new Rule("ieHack", localize3("rule.ieHack", "IE hacks are only necessary when supporting IE7 and older"), Ignore),
  UnknownVendorSpecificProperty: new Rule("unknownVendorSpecificProperties", localize3("rule.unknownVendorSpecificProperty", "Unknown vendor specific property."), Ignore),
  PropertyIgnoredDueToDisplay: new Rule("propertyIgnoredDueToDisplay", localize3("rule.propertyIgnoredDueToDisplay", "Property is ignored due to the display."), Warning),
  AvoidImportant: new Rule("important", localize3("rule.avoidImportant", "Avoid using !important. It is an indication that the specificity of the entire CSS has gotten out of control and needs to be refactored."), Ignore),
  AvoidFloat: new Rule("float", localize3("rule.avoidFloat", "Avoid using 'float'. Floats lead to fragile CSS that is easy to break if one aspect of the layout changes."), Ignore),
  AvoidIdSelector: new Rule("idSelector", localize3("rule.avoidIdSelector", "Selectors should not contain IDs because these rules are too tightly coupled with the HTML."), Ignore)
};
var Settings = {
  ValidProperties: new Setting("validProperties", localize3("rule.validProperties", "A list of properties that are not validated against the `unknownProperties` rule."), [])
};
var LintConfigurationSettings = class {
  constructor(conf = {}) {
    this.conf = conf;
  }
  getRule(rule) {
    if (this.conf.hasOwnProperty(rule.id)) {
      const level = toLevel(this.conf[rule.id]);
      if (level) {
        return level;
      }
    }
    return rule.defaultValue;
  }
  getSetting(setting) {
    return this.conf[setting.id];
  }
};
function toLevel(level) {
  switch (level) {
    case "ignore":
      return 1 /* Ignore */;
    case "warning":
      return 2 /* Warning */;
    case "error":
      return 4 /* Error */;
  }
  return null;
}

// src/vscode-css-languageservice/services/cssCodeActions.ts
import * as nls4 from "vscode-nls";
var localize4 = nls4.loadMessageBundle();
var CSSCodeActions = class {
  constructor(cssDataManager) {
    this.cssDataManager = cssDataManager;
  }
  doCodeActions(document, range, context, stylesheet) {
    return this.doCodeActions2(document, range, context, stylesheet).map((ca) => {
      const textDocumentEdit = ca.edit && ca.edit.documentChanges && ca.edit.documentChanges[0];
      return Command.create(ca.title, "_css.applyCodeAction", document.uri, document.version, textDocumentEdit && textDocumentEdit.edits);
    });
  }
  doCodeActions2(document, range, context, stylesheet) {
    const result = [];
    if (context.diagnostics) {
      for (const diagnostic of context.diagnostics) {
        this.appendFixesForMarker(document, stylesheet, diagnostic, result);
      }
    }
    return result;
  }
  getFixesForUnknownProperty(document, property, marker, result) {
    const propertyName = property.getName();
    const candidates = [];
    this.cssDataManager.getProperties().forEach((p) => {
      const score = difference(propertyName, p.name);
      if (score >= propertyName.length / 2) {
        candidates.push({ property: p.name, score });
      }
    });
    candidates.sort((a2, b) => {
      return b.score - a2.score || a2.property.localeCompare(b.property);
    });
    let maxActions = 3;
    for (const candidate of candidates) {
      const propertyName2 = candidate.property;
      const title = localize4("css.codeaction.rename", "Rename to '{0}'", propertyName2);
      const edit = TextEdit.replace(marker.range, propertyName2);
      const documentIdentifier = VersionedTextDocumentIdentifier.create(document.uri, document.version);
      const workspaceEdit = { documentChanges: [TextDocumentEdit.create(documentIdentifier, [edit])] };
      const codeAction = CodeAction.create(title, workspaceEdit, CodeActionKind.QuickFix);
      codeAction.diagnostics = [marker];
      result.push(codeAction);
      if (--maxActions <= 0) {
        return;
      }
    }
  }
  appendFixesForMarker(document, stylesheet, marker, result) {
    if (marker.code !== Rules.UnknownProperty.id) {
      return;
    }
    const offset = document.offsetAt(marker.range.start);
    const end = document.offsetAt(marker.range.end);
    const nodepath = getNodePath(stylesheet, offset);
    for (let i = nodepath.length - 1; i >= 0; i--) {
      const node = nodepath[i];
      if (node instanceof Declaration) {
        const property = node.getProperty();
        if (property && property.offset === offset && property.end === end) {
          this.getFixesForUnknownProperty(document, property, marker, result);
          return;
        }
      }
    }
  }
};

// src/vscode-css-languageservice/services/lint.ts
import * as nls5 from "vscode-nls";

// src/vscode-css-languageservice/utils/arrays.ts
function findFirst(array, p) {
  let low = 0, high = array.length;
  if (high === 0) {
    return 0;
  }
  while (low < high) {
    const mid = Math.floor((low + high) / 2);
    if (p(array[mid])) {
      high = mid;
    } else {
      low = mid + 1;
    }
  }
  return low;
}
function includes(array, item) {
  return array.indexOf(item) !== -1;
}
function union(...arrays) {
  const result = [];
  for (const array of arrays) {
    for (const item of array) {
      if (!includes(result, item)) {
        result.push(item);
      }
    }
  }
  return result;
}

// src/vscode-css-languageservice/services/lintUtil.ts
var Element2 = class {
  constructor(decl) {
    this.fullPropertyName = decl.getFullPropertyName().toLowerCase();
    this.node = decl;
  }
};
function setSide(model, side, value, property) {
  const state = model[side];
  state.value = value;
  if (value) {
    if (!includes(state.properties, property)) {
      state.properties.push(property);
    }
  }
}
function setAllSides(model, value, property) {
  setSide(model, "top", value, property);
  setSide(model, "right", value, property);
  setSide(model, "bottom", value, property);
  setSide(model, "left", value, property);
}
function updateModelWithValue(model, side, value, property) {
  if (side === "top" || side === "right" || side === "bottom" || side === "left") {
    setSide(model, side, value, property);
  } else {
    setAllSides(model, value, property);
  }
}
function updateModelWithList(model, values2, property) {
  switch (values2.length) {
    case 1:
      updateModelWithValue(model, void 0, values2[0], property);
      break;
    case 2:
      updateModelWithValue(model, "top", values2[0], property);
      updateModelWithValue(model, "bottom", values2[0], property);
      updateModelWithValue(model, "right", values2[1], property);
      updateModelWithValue(model, "left", values2[1], property);
      break;
    case 3:
      updateModelWithValue(model, "top", values2[0], property);
      updateModelWithValue(model, "right", values2[1], property);
      updateModelWithValue(model, "left", values2[1], property);
      updateModelWithValue(model, "bottom", values2[2], property);
      break;
    case 4:
      updateModelWithValue(model, "top", values2[0], property);
      updateModelWithValue(model, "right", values2[1], property);
      updateModelWithValue(model, "bottom", values2[2], property);
      updateModelWithValue(model, "left", values2[3], property);
      break;
  }
}
function matches(value, candidates) {
  for (const candidate of candidates) {
    if (value.matches(candidate)) {
      return true;
    }
  }
  return false;
}
function checkLineWidth(value, allowsKeywords = true) {
  if (allowsKeywords && matches(value, ["initial", "unset"])) {
    return false;
  }
  return parseFloat(value.getText()) !== 0;
}
function checkLineWidthList(nodes, allowsKeywords = true) {
  return nodes.map((node) => checkLineWidth(node, allowsKeywords));
}
function checkLineStyle(valueNode, allowsKeywords = true) {
  if (matches(valueNode, ["none", "hidden"])) {
    return false;
  }
  if (allowsKeywords && matches(valueNode, ["initial", "unset"])) {
    return false;
  }
  return true;
}
function checkLineStyleList(nodes, allowsKeywords = true) {
  return nodes.map((node) => checkLineStyle(node, allowsKeywords));
}
function checkBorderShorthand(node) {
  const children = node.getChildren();
  if (children.length === 1) {
    const value = children[0];
    return checkLineWidth(value) && checkLineStyle(value);
  }
  for (const child of children) {
    const value = child;
    if (!checkLineWidth(value, false) || !checkLineStyle(value, false)) {
      return false;
    }
  }
  return true;
}
function calculateBoxModel(propertyTable) {
  const model = {
    top: { value: false, properties: [] },
    right: { value: false, properties: [] },
    bottom: { value: false, properties: [] },
    left: { value: false, properties: [] }
  };
  for (const property of propertyTable) {
    const value = property.node.value;
    if (typeof value === "undefined") {
      continue;
    }
    switch (property.fullPropertyName) {
      case "box-sizing":
        return {
          top: { value: false, properties: [] },
          right: { value: false, properties: [] },
          bottom: { value: false, properties: [] },
          left: { value: false, properties: [] }
        };
      case "width":
        model.width = property;
        break;
      case "height":
        model.height = property;
        break;
      default:
        const segments = property.fullPropertyName.split("-");
        switch (segments[0]) {
          case "border":
            switch (segments[1]) {
              case void 0:
              case "top":
              case "right":
              case "bottom":
              case "left":
                switch (segments[2]) {
                  case void 0:
                    updateModelWithValue(model, segments[1], checkBorderShorthand(value), property);
                    break;
                  case "width":
                    updateModelWithValue(model, segments[1], checkLineWidth(value, false), property);
                    break;
                  case "style":
                    updateModelWithValue(model, segments[1], checkLineStyle(value, true), property);
                    break;
                }
                break;
              case "width":
                updateModelWithList(model, checkLineWidthList(value.getChildren(), false), property);
                break;
              case "style":
                updateModelWithList(model, checkLineStyleList(value.getChildren(), true), property);
                break;
            }
            break;
          case "padding":
            if (segments.length === 1) {
              updateModelWithList(model, checkLineWidthList(value.getChildren(), true), property);
            } else {
              updateModelWithValue(model, segments[1], checkLineWidth(value, true), property);
            }
            break;
        }
        break;
    }
  }
  return model;
}

// src/vscode-css-languageservice/services/lint.ts
var localize5 = nls5.loadMessageBundle();
var NodesByRootMap = class {
  constructor() {
    this.data = {};
  }
  add(root, name, node) {
    let entry = this.data[root];
    if (!entry) {
      entry = { nodes: [], names: [] };
      this.data[root] = entry;
    }
    entry.names.push(name);
    if (node) {
      entry.nodes.push(node);
    }
  }
};
var _LintVisitor = class {
  constructor(document, settings, cssDataManager) {
    this.cssDataManager = cssDataManager;
    this.warnings = [];
    this.settings = settings;
    this.documentText = document.getText();
    this.keyframes = new NodesByRootMap();
    this.validProperties = {};
    const properties = settings.getSetting(Settings.ValidProperties);
    if (Array.isArray(properties)) {
      properties.forEach((p) => {
        if (typeof p === "string") {
          const name = p.trim().toLowerCase();
          if (name.length) {
            this.validProperties[name] = true;
          }
        }
      });
    }
  }
  static entries(node, document, settings, cssDataManager, entryFilter) {
    const visitor = new _LintVisitor(document, settings, cssDataManager);
    node.acceptVisitor(visitor);
    visitor.completeValidations();
    return visitor.getEntries(entryFilter);
  }
  isValidPropertyDeclaration(element) {
    const propertyName = element.fullPropertyName;
    return this.validProperties[propertyName];
  }
  fetch(input, s) {
    const elements = [];
    for (const curr of input) {
      if (curr.fullPropertyName === s) {
        elements.push(curr);
      }
    }
    return elements;
  }
  fetchWithValue(input, s, v) {
    const elements = [];
    for (const inputElement of input) {
      if (inputElement.fullPropertyName === s) {
        const expression = inputElement.node.getValue();
        if (expression && this.findValueInExpression(expression, v)) {
          elements.push(inputElement);
        }
      }
    }
    return elements;
  }
  findValueInExpression(expression, v) {
    let found = false;
    expression.accept((node) => {
      if (node.type === 1 /* Identifier */ && node.matches(v)) {
        found = true;
      }
      return !found;
    });
    return found;
  }
  getEntries(filter = 2 /* Warning */ | 4 /* Error */) {
    return this.warnings.filter((entry) => {
      return (entry.getLevel() & filter) !== 0;
    });
  }
  addEntry(node, rule, details) {
    const entry = new Marker(node, rule, this.settings.getRule(rule), details);
    this.warnings.push(entry);
  }
  getMissingNames(expected, actual) {
    const expectedClone = expected.slice(0);
    for (let i = 0; i < actual.length; i++) {
      const k = expectedClone.indexOf(actual[i]);
      if (k !== -1) {
        expectedClone[k] = null;
      }
    }
    let result = null;
    for (let i = 0; i < expectedClone.length; i++) {
      const curr = expectedClone[i];
      if (curr) {
        if (result === null) {
          result = localize5("namelist.single", "'{0}'", curr);
        } else {
          result = localize5("namelist.concatenated", "{0}, '{1}'", result, curr);
        }
      }
    }
    return result;
  }
  visitNode(node) {
    switch (node.type) {
      case 76 /* UnknownAtRule */:
        return this.visitUnknownAtRule(node);
      case 52 /* Keyframe */:
        return this.visitKeyframe(node);
      case 53 /* FontFace */:
        return this.visitFontFace(node);
      case 3 /* Ruleset */:
        return this.visitRuleSet(node);
      case 5 /* SimpleSelector */:
        return this.visitSimpleSelector(node);
      case 30 /* Function */:
        return this.visitFunction(node);
      case 31 /* NumericValue */:
        return this.visitNumericValue(node);
      case 54 /* Import */:
        return this.visitImport(node);
      case 32 /* HexColorValue */:
        return this.visitHexColorValue(node);
      case 38 /* Prio */:
        return this.visitPrio(node);
      case 15 /* IdentifierSelector */:
        return this.visitIdentifierSelector(node);
    }
    return true;
  }
  completeValidations() {
    this.validateKeyframes();
  }
  visitUnknownAtRule(node) {
    const atRuleName = node.getChild(0);
    if (!atRuleName) {
      return false;
    }
    const atDirective = this.cssDataManager.getAtDirective(atRuleName.getText());
    if (atDirective) {
      return false;
    }
    this.addEntry(atRuleName, Rules.UnknownAtRules, `Unknown at rule ${atRuleName.getText()}`);
    return true;
  }
  visitKeyframe(node) {
    const keyword = node.getKeyword();
    if (!keyword) {
      return false;
    }
    const text = keyword.getText();
    this.keyframes.add(node.getName(), text, text !== "@keyframes" ? keyword : null);
    return true;
  }
  validateKeyframes() {
    const expected = ["@-webkit-keyframes", "@-moz-keyframes", "@-o-keyframes"];
    for (const name in this.keyframes.data) {
      const actual = this.keyframes.data[name].names;
      const needsStandard = actual.indexOf("@keyframes") === -1;
      if (!needsStandard && actual.length === 1) {
        continue;
      }
      const missingVendorSpecific = this.getMissingNames(expected, actual);
      if (missingVendorSpecific || needsStandard) {
        for (const node of this.keyframes.data[name].nodes) {
          if (needsStandard) {
            const message = localize5("keyframes.standardrule.missing", "Always define standard rule '@keyframes' when defining keyframes.");
            this.addEntry(node, Rules.IncludeStandardPropertyWhenUsingVendorPrefix, message);
          }
          if (missingVendorSpecific) {
            const message = localize5("keyframes.vendorspecific.missing", "Always include all vendor specific rules: Missing: {0}", missingVendorSpecific);
            this.addEntry(node, Rules.AllVendorPrefixes, message);
          }
        }
      }
    }
    return true;
  }
  visitSimpleSelector(node) {
    const firstChar = this.documentText.charAt(node.offset);
    if (node.length === 1 && firstChar === "*") {
      this.addEntry(node, Rules.UniversalSelector);
    }
    return true;
  }
  visitIdentifierSelector(node) {
    this.addEntry(node, Rules.AvoidIdSelector);
    return true;
  }
  visitImport(node) {
    this.addEntry(node, Rules.ImportStatemement);
    return true;
  }
  visitRuleSet(node) {
    const declarations = node.getDeclarations();
    if (!declarations) {
      return false;
    }
    if (!declarations.hasChildren()) {
      this.addEntry(node.getSelectors(), Rules.EmptyRuleSet);
    }
    const propertyTable = [];
    for (const element of declarations.getChildren()) {
      if (element instanceof Declaration) {
        propertyTable.push(new Element2(element));
      }
    }
    const boxModel = calculateBoxModel(propertyTable);
    if (boxModel.width) {
      let properties = [];
      if (boxModel.right.value) {
        properties = union(properties, boxModel.right.properties);
      }
      if (boxModel.left.value) {
        properties = union(properties, boxModel.left.properties);
      }
      if (properties.length !== 0) {
        for (const item of properties) {
          this.addEntry(item.node, Rules.BewareOfBoxModelSize);
        }
        this.addEntry(boxModel.width.node, Rules.BewareOfBoxModelSize);
      }
    }
    if (boxModel.height) {
      let properties = [];
      if (boxModel.top.value) {
        properties = union(properties, boxModel.top.properties);
      }
      if (boxModel.bottom.value) {
        properties = union(properties, boxModel.bottom.properties);
      }
      if (properties.length !== 0) {
        for (const item of properties) {
          this.addEntry(item.node, Rules.BewareOfBoxModelSize);
        }
        this.addEntry(boxModel.height.node, Rules.BewareOfBoxModelSize);
      }
    }
    let displayElems = this.fetchWithValue(propertyTable, "display", "inline-block");
    if (displayElems.length > 0) {
      const elem = this.fetch(propertyTable, "float");
      for (let index = 0; index < elem.length; index++) {
        const node2 = elem[index].node;
        const value = node2.getValue();
        if (value && !value.matches("none")) {
          this.addEntry(node2, Rules.PropertyIgnoredDueToDisplay, localize5("rule.propertyIgnoredDueToDisplayInlineBlock", "inline-block is ignored due to the float. If 'float' has a value other than 'none', the box is floated and 'display' is treated as 'block'"));
        }
      }
    }
    displayElems = this.fetchWithValue(propertyTable, "display", "block");
    if (displayElems.length > 0) {
      const elem = this.fetch(propertyTable, "vertical-align");
      for (let index = 0; index < elem.length; index++) {
        this.addEntry(elem[index].node, Rules.PropertyIgnoredDueToDisplay, localize5("rule.propertyIgnoredDueToDisplayBlock", "Property is ignored due to the display. With 'display: block', vertical-align should not be used."));
      }
    }
    const elements = this.fetch(propertyTable, "float");
    for (let index = 0; index < elements.length; index++) {
      const element = elements[index];
      if (!this.isValidPropertyDeclaration(element)) {
        this.addEntry(element.node, Rules.AvoidFloat);
      }
    }
    for (let i = 0; i < propertyTable.length; i++) {
      const element = propertyTable[i];
      if (element.fullPropertyName !== "background" && !this.validProperties[element.fullPropertyName]) {
        const value = element.node.getValue();
        if (value && this.documentText.charAt(value.offset) !== "-") {
          const elements2 = this.fetch(propertyTable, element.fullPropertyName);
          if (elements2.length > 1) {
            for (let k = 0; k < elements2.length; k++) {
              const value2 = elements2[k].node.getValue();
              if (value2 && this.documentText.charAt(value2.offset) !== "-" && elements2[k] !== element) {
                this.addEntry(element.node, Rules.DuplicateDeclarations);
              }
            }
          }
        }
      }
    }
    const isExportBlock = node.getSelectors().matches(":export");
    if (!isExportBlock) {
      const propertiesBySuffix = new NodesByRootMap();
      let containsUnknowns = false;
      for (const element of propertyTable) {
        const decl = element.node;
        if (this.isCSSDeclaration(decl)) {
          let name = element.fullPropertyName;
          const firstChar = name.charAt(0);
          if (firstChar === "-") {
            if (name.charAt(1) !== "-") {
              if (!this.cssDataManager.isKnownProperty(name) && !this.validProperties[name]) {
                this.addEntry(decl.getProperty(), Rules.UnknownVendorSpecificProperty);
              }
              const nonPrefixedName = decl.getNonPrefixedPropertyName();
              propertiesBySuffix.add(nonPrefixedName, name, decl.getProperty());
            }
          } else {
            const fullName = name;
            if (firstChar === "*" || firstChar === "_") {
              this.addEntry(decl.getProperty(), Rules.IEStarHack);
              name = name.substr(1);
            }
            if (!this.cssDataManager.isKnownProperty(fullName) && !this.cssDataManager.isKnownProperty(name)) {
              if (!this.validProperties[name]) {
                this.addEntry(decl.getProperty(), Rules.UnknownProperty, localize5("property.unknownproperty.detailed", "Unknown property: '{0}'", decl.getFullPropertyName()));
              }
            }
            propertiesBySuffix.add(name, name, null);
          }
        } else {
          containsUnknowns = true;
        }
      }
      if (!containsUnknowns) {
        for (const suffix in propertiesBySuffix.data) {
          const entry = propertiesBySuffix.data[suffix];
          const actual = entry.names;
          const needsStandard = this.cssDataManager.isStandardProperty(suffix) && actual.indexOf(suffix) === -1;
          if (!needsStandard && actual.length === 1) {
            continue;
          }
          const expected = [];
          for (let i = 0, len = _LintVisitor.prefixes.length; i < len; i++) {
            const prefix = _LintVisitor.prefixes[i];
            if (this.cssDataManager.isStandardProperty(prefix + suffix)) {
              expected.push(prefix + suffix);
            }
          }
          const missingVendorSpecific = this.getMissingNames(expected, actual);
          if (missingVendorSpecific || needsStandard) {
            for (const node2 of entry.nodes) {
              if (needsStandard) {
                const message = localize5("property.standard.missing", "Also define the standard property '{0}' for compatibility", suffix);
                this.addEntry(node2, Rules.IncludeStandardPropertyWhenUsingVendorPrefix, message);
              }
              if (missingVendorSpecific) {
                const message = localize5("property.vendorspecific.missing", "Always include all vendor specific properties: Missing: {0}", missingVendorSpecific);
                this.addEntry(node2, Rules.AllVendorPrefixes, message);
              }
            }
          }
        }
      }
    }
    return true;
  }
  visitPrio(node) {
    this.addEntry(node, Rules.AvoidImportant);
    return true;
  }
  visitNumericValue(node) {
    const funcDecl = node.findParent(30 /* Function */);
    if (funcDecl && funcDecl.getName() === "calc") {
      return true;
    }
    const decl = node.findParent(19 /* Declaration */);
    if (decl) {
      const declValue = decl.getValue();
      if (declValue) {
        const value = node.getValue();
        if (!value.unit || units.length.indexOf(value.unit.toLowerCase()) === -1) {
          return true;
        }
        if (parseFloat(value.value) === 0 && !!value.unit && !this.validProperties[decl.getFullPropertyName()]) {
          this.addEntry(node, Rules.ZeroWithUnit);
        }
      }
    }
    return true;
  }
  visitFontFace(node) {
    const declarations = node.getDeclarations();
    if (!declarations) {
      return false;
    }
    let definesSrc = false, definesFontFamily = false;
    let containsUnknowns = false;
    for (const node2 of declarations.getChildren()) {
      if (this.isCSSDeclaration(node2)) {
        const name = node2.getProperty().getName().toLowerCase();
        if (name === "src") {
          definesSrc = true;
        }
        if (name === "font-family") {
          definesFontFamily = true;
        }
      } else {
        containsUnknowns = true;
      }
    }
    if (!containsUnknowns && (!definesSrc || !definesFontFamily)) {
      this.addEntry(node, Rules.RequiredPropertiesForFontFace);
    }
    return true;
  }
  isCSSDeclaration(node) {
    if (node instanceof Declaration) {
      if (!node.getValue()) {
        return false;
      }
      const property = node.getProperty();
      if (!property) {
        return false;
      }
      const identifier = property.getIdentifier();
      if (!identifier || identifier.containsInterpolation()) {
        return false;
      }
      return true;
    }
    return false;
  }
  visitHexColorValue(node) {
    const length = node.length;
    if (length !== 9 && length !== 7 && length !== 5 && length !== 4) {
      this.addEntry(node, Rules.HexColorLength);
    }
    return false;
  }
  visitFunction(node) {
    const fnName = node.getName().toLowerCase();
    let expectedAttrCount = -1;
    let actualAttrCount = 0;
    switch (fnName) {
      case "rgb(":
      case "hsl(":
        expectedAttrCount = 3;
        break;
      case "rgba(":
      case "hsla(":
        expectedAttrCount = 4;
        break;
    }
    if (expectedAttrCount !== -1) {
      node.getArguments().accept((n) => {
        if (n instanceof BinaryExpression) {
          actualAttrCount += 1;
          return false;
        }
        return true;
      });
      if (actualAttrCount !== expectedAttrCount) {
        this.addEntry(node, Rules.ArgsInColorFunction);
      }
    }
    return true;
  }
};
var LintVisitor = _LintVisitor;
LintVisitor.prefixes = [
  "-ms-",
  "-moz-",
  "-o-",
  "-webkit-"
];

// src/vscode-css-languageservice/services/cssValidation.ts
var CSSValidation = class {
  constructor(cssDataManager) {
    this.cssDataManager = cssDataManager;
  }
  configure(settings) {
    this.settings = settings;
  }
  doValidation(document, stylesheet, settings = this.settings) {
    if (settings && settings.validate === false) {
      return [];
    }
    const entries = [];
    entries.push.apply(entries, ParseErrorCollector.entries(stylesheet));
    entries.push.apply(
      entries,
      LintVisitor.entries(
        stylesheet,
        document,
        new LintConfigurationSettings(settings && settings.lint),
        this.cssDataManager
      )
    );
    function toDiagnostic(marker) {
      const range = Range.create(
        document.positionAt(marker.getOffset()),
        document.positionAt(marker.getOffset() + marker.getLength())
      );
      const source = document.languageId;
      return {
        code: marker.getRule().id,
        source,
        message: marker.getMessage(),
        severity: marker.getLevel() === 2 /* Warning */ ? DiagnosticSeverity.Warning : DiagnosticSeverity.Error,
        range
      };
    }
    return entries.filter((entry) => entry.getLevel() !== 1 /* Ignore */).map(toDiagnostic);
  }
};

// src/vscode-css-languageservice/parser/postCSSScanner.ts
var _FSL2 = "/".charCodeAt(0);
var _NWL2 = "\n".charCodeAt(0);
var _CAR2 = "\r".charCodeAt(0);
var _LFD2 = "\f".charCodeAt(0);
var _DLR2 = "$".charCodeAt(0);
var _HSH2 = "$".charCodeAt(0);
var _CUL2 = "(".charCodeAt(0);
var _EQS2 = "=".charCodeAt(0);
var _BNG2 = "!".charCodeAt(0);
var _LAN2 = "<".charCodeAt(0);
var _RAN2 = ">".charCodeAt(0);
var _DOT2 = ".".charCodeAt(0);
var _ATS2 = "@".charCodeAt(0);
var customTokenValue = 42 /* CustomToken */;
var VariableName = customTokenValue++;
var InterpolationFunction = customTokenValue++;
var Default = customTokenValue++;
var EqualsOperator = customTokenValue++;
var NotEqualsOperator = customTokenValue++;
var GreaterEqualsOperator = customTokenValue++;
var SmallerEqualsOperator = customTokenValue++;
var Ellipsis = customTokenValue++;
var Module2 = customTokenValue++;
var PostCSSScanner = class extends Scanner {
  scanNext(offset) {
    if (this.stream.advanceIfChar(_DLR2)) {
      const content = ["$"];
      if (this.ident(content)) {
        return this.finishToken(offset, VariableName, content.join(""));
      } else {
        this.stream.goBackTo(offset);
      }
    }
    if (this.stream.advanceIfChars([_HSH2, _CUL2])) {
      return this.finishToken(offset, InterpolationFunction);
    }
    if (this.stream.advanceIfChars([_EQS2, _EQS2])) {
      return this.finishToken(offset, EqualsOperator);
    }
    if (this.stream.advanceIfChars([_BNG2, _EQS2])) {
      return this.finishToken(offset, NotEqualsOperator);
    }
    if (this.stream.advanceIfChar(_LAN2)) {
      if (this.stream.advanceIfChar(_EQS2)) {
        return this.finishToken(offset, SmallerEqualsOperator);
      }
      return this.finishToken(offset, 26 /* Delim */);
    }
    if (this.stream.advanceIfChar(_RAN2)) {
      if (this.stream.advanceIfChar(_EQS2)) {
        return this.finishToken(offset, GreaterEqualsOperator);
      }
      return this.finishToken(offset, 26 /* Delim */);
    }
    if (this.stream.advanceIfChars([_DOT2, _DOT2, _DOT2])) {
      return this.finishToken(offset, Ellipsis);
    }
    return super.scanNext(offset);
  }
  comment() {
    if (super.comment()) {
      return true;
    }
    if (!this.inURL && this.stream.advanceIfChars([_FSL2, _FSL2])) {
      this.stream.advanceWhileChar((ch) => {
        switch (ch) {
          case _NWL2:
          case _CAR2:
          case _LFD2:
            return false;
          default:
            return true;
        }
      });
      return true;
    } else {
      return false;
    }
  }
};

// src/vscode-css-languageservice/services/cssFolding.ts
function getFoldingRanges(document, context) {
  const ranges = computeFoldingRanges(document);
  return limitFoldingRanges(ranges, context);
}
function computeFoldingRanges(document) {
  function getStartLine(t) {
    return document.positionAt(t.offset).line;
  }
  function getEndLine(t) {
    return document.positionAt(t.offset + t.len).line;
  }
  function getScanner() {
    return new PostCSSScanner();
  }
  function tokenToRange(t, kind) {
    const startLine = getStartLine(t);
    const endLine = getEndLine(t);
    if (startLine !== endLine) {
      return {
        startLine,
        endLine,
        kind
      };
    } else {
      return null;
    }
  }
  const ranges = [];
  const delimiterStack = [];
  const scanner = getScanner();
  scanner.ignoreComment = false;
  scanner.setSource(document.getText());
  let token = scanner.scan();
  let prevToken = null;
  while (token.type !== 41 /* EOF */) {
    switch (token.type) {
      case 14 /* CurlyL */:
      case InterpolationFunction: {
        delimiterStack.push({ line: getStartLine(token), type: "brace", isStart: true });
        break;
      }
      case 15 /* CurlyR */: {
        if (delimiterStack.length !== 0) {
          const prevDelimiter = popPrevStartDelimiterOfType(delimiterStack, "brace");
          if (!prevDelimiter) {
            break;
          }
          let endLine = getEndLine(token);
          if (prevDelimiter.type === "brace") {
            if (prevToken && getEndLine(prevToken) !== endLine) {
              endLine--;
            }
            if (prevDelimiter.line !== endLine) {
              ranges.push({
                startLine: prevDelimiter.line,
                endLine,
                kind: void 0
              });
            }
          }
        }
        break;
      }
      case 39 /* Comment */: {
        const commentRegionMarkerToDelimiter = (marker) => {
          if (marker === "#region") {
            return { line: getStartLine(token), type: "comment", isStart: true };
          } else {
            return { line: getEndLine(token), type: "comment", isStart: false };
          }
        };
        const getCurrDelimiter = (token2) => {
          const matches2 = token2.text.match(/^\s*\/\*\s*(#region|#endregion)\b\s*(.*?)\s*\*\//);
          if (matches2) {
            return commentRegionMarkerToDelimiter(matches2[1]);
          } else if (document.languageId === "scss" || document.languageId === "less") {
            const matches3 = token2.text.match(/^\s*\/\/\s*(#region|#endregion)\b\s*(.*?)\s*/);
            if (matches3) {
              return commentRegionMarkerToDelimiter(matches3[1]);
            }
          }
          return null;
        };
        const currDelimiter = getCurrDelimiter(token);
        if (currDelimiter) {
          if (currDelimiter.isStart) {
            delimiterStack.push(currDelimiter);
          } else {
            const prevDelimiter = popPrevStartDelimiterOfType(delimiterStack, "comment");
            if (!prevDelimiter) {
              break;
            }
            if (prevDelimiter.type === "comment") {
              if (prevDelimiter.line !== currDelimiter.line) {
                ranges.push({
                  startLine: prevDelimiter.line,
                  endLine: currDelimiter.line,
                  kind: "region"
                });
              }
            }
          }
        } else {
          const range = tokenToRange(token, "comment");
          if (range) {
            ranges.push(range);
          }
        }
        break;
      }
    }
    prevToken = token;
    token = scanner.scan();
  }
  return ranges;
}
function popPrevStartDelimiterOfType(stack, type) {
  if (stack.length === 0) {
    return null;
  }
  for (let i = stack.length - 1; i >= 0; i--) {
    if (stack[i].type === type && stack[i].isStart) {
      return stack.splice(i, 1)[0];
    }
  }
  return null;
}
function limitFoldingRanges(ranges, context) {
  const maxRanges = context && context.rangeLimit || Number.MAX_VALUE;
  const sortedRanges = ranges.sort((r1, r2) => {
    let diff = r1.startLine - r2.startLine;
    if (diff === 0) {
      diff = r1.endLine - r2.endLine;
    }
    return diff;
  });
  const validRanges = [];
  let prevEndLine = -1;
  sortedRanges.forEach((r) => {
    if (!(r.startLine < prevEndLine && prevEndLine < r.endLine)) {
      validRanges.push(r);
      prevEndLine = r.endLine;
    }
  });
  if (validRanges.length < maxRanges) {
    return validRanges;
  } else {
    return validRanges.slice(0, maxRanges);
  }
}

// src/vscode-css-languageservice/data/postCSSCustomData.ts
var postCSSCustomData = {
  version: 1,
  properties: [
    {
      name: "composes",
      status: "nonstandard",
      references: [
        {
          name: "CSS Modules Reference",
          url: "https://github.com/css-modules/css-modules#composition"
        }
      ],
      description: "CSS Modules composes multiple selectors into one. This property allows you to specify which selectors should be composed into one."
    }
  ],
  atDirectives: [
    {
      "name": "@custom-media",
      "browsers": [],
      status: "experimental",
      "description": "An at-rule for defining aliases that represent media queries."
    },
    {
      "name": "@custom-selector",
      "browsers": [],
      status: "experimental",
      "description": "An at-rule for defining aliases that represent selectors."
    },
    {
      "name": "@nest",
      "references": [
        {
          "name": "W3 Reference",
          "url": "https://www.w3.org/TR/css-nesting-1/#at-nest"
        }
      ],
      status: "experimental",
      "description": "Nested keyword."
    },
    {
      "name": "@define-mixin",
      status: "nonstandard",
      "description": "SCSS @mixin declaration replacement."
    }
  ],
  pseudoClasses: [],
  pseudoElements: []
};

// src/vscode-css-languageservice/data/webCustomData.ts
import { getDefaultCSSDataProvider } from "vscode-css-languageservice";
var cssProvider = getDefaultCSSDataProvider();
var cssData = {
  version: 1.1,
  atDirectives: cssProvider.provideAtDirectives().concat(postCSSCustomData.atDirectives),
  properties: cssProvider.provideProperties().concat(postCSSCustomData.properties),
  pseudoClasses: cssProvider.providePseudoClasses().concat(postCSSCustomData.pseudoClasses),
  pseudoElements: cssProvider.providePseudoElements().concat(postCSSCustomData.pseudoElements)
};

// src/vscode-css-languageservice/languageFacts/dataProvider.ts
var CSSDataProvider = class {
  constructor(data) {
    this._properties = [];
    this._atDirectives = [];
    this._pseudoClasses = [];
    this._pseudoElements = [];
    this.addData(data);
  }
  provideProperties() {
    return this._properties;
  }
  provideAtDirectives() {
    return this._atDirectives;
  }
  providePseudoClasses() {
    return this._pseudoClasses;
  }
  providePseudoElements() {
    return this._pseudoElements;
  }
  addData(data) {
    if (Array.isArray(data.properties)) {
      for (const prop of data.properties) {
        if (isPropertyData(prop)) {
          this._properties.push(prop);
        }
      }
    }
    if (Array.isArray(data.atDirectives)) {
      for (const prop of data.atDirectives) {
        if (isAtDirective(prop)) {
          this._atDirectives.push(prop);
        }
      }
    }
    if (Array.isArray(data.pseudoClasses)) {
      for (const prop of data.pseudoClasses) {
        if (isPseudoClassData(prop)) {
          this._pseudoClasses.push(prop);
        }
      }
    }
    if (Array.isArray(data.pseudoElements)) {
      for (const prop of data.pseudoElements) {
        if (isPseudoElementData(prop)) {
          this._pseudoElements.push(prop);
        }
      }
    }
  }
};
function isPropertyData(d) {
  return typeof d.name === "string";
}
function isAtDirective(d) {
  return typeof d.name === "string";
}
function isPseudoClassData(d) {
  return typeof d.name === "string";
}
function isPseudoElementData(d) {
  return typeof d.name === "string";
}

// src/vscode-css-languageservice/languageFacts/dataManager.ts
var CSSDataManager = class {
  constructor(options) {
    this.dataProviders = [];
    this._propertySet = {};
    this._atDirectiveSet = {};
    this._pseudoClassSet = {};
    this._pseudoElementSet = {};
    this._properties = [];
    this._atDirectives = [];
    this._pseudoClasses = [];
    this._pseudoElements = [];
    this.setDataProviders((options == null ? void 0 : options.useDefaultDataProvider) !== false, (options == null ? void 0 : options.customDataProviders) || []);
  }
  setDataProviders(builtIn, providers) {
    this.dataProviders = [];
    if (builtIn) {
      this.dataProviders.push(new CSSDataProvider(cssData));
    }
    this.dataProviders.push(...providers);
    this.collectData();
  }
  collectData() {
    this._propertySet = {};
    this._atDirectiveSet = {};
    this._pseudoClassSet = {};
    this._pseudoElementSet = {};
    this.dataProviders.forEach((provider) => {
      provider.provideProperties().forEach((p) => {
        if (!this._propertySet[p.name]) {
          this._propertySet[p.name] = p;
        }
      });
      provider.provideAtDirectives().forEach((p) => {
        if (!this._atDirectiveSet[p.name]) {
          this._atDirectiveSet[p.name] = p;
        }
      });
      provider.providePseudoClasses().forEach((p) => {
        if (!this._pseudoClassSet[p.name]) {
          this._pseudoClassSet[p.name] = p;
        }
      });
      provider.providePseudoElements().forEach((p) => {
        if (!this._pseudoElementSet[p.name]) {
          this._pseudoElementSet[p.name] = p;
        }
      });
    });
    this._properties = values(this._propertySet);
    this._atDirectives = values(this._atDirectiveSet);
    this._pseudoClasses = values(this._pseudoClassSet);
    this._pseudoElements = values(this._pseudoElementSet);
  }
  getProperty(name) {
    return this._propertySet[name];
  }
  getAtDirective(name) {
    return this._atDirectiveSet[name];
  }
  getPseudoClass(name) {
    return this._pseudoClassSet[name];
  }
  getPseudoElement(name) {
    return this._pseudoElementSet[name];
  }
  getProperties() {
    return this._properties;
  }
  getAtDirectives() {
    return this._atDirectives;
  }
  getPseudoClasses() {
    return this._pseudoClasses;
  }
  getPseudoElements() {
    return this._pseudoElements;
  }
  isKnownProperty(name) {
    return name.toLowerCase() in this._propertySet;
  }
  isStandardProperty(name) {
    return this.isKnownProperty(name) && (!this._propertySet[name.toLowerCase()].status || this._propertySet[name.toLowerCase()].status === "standard");
  }
};

// src/vscode-css-languageservice/services/cssSelectionRange.ts
function getSelectionRanges(document, positions, stylesheet) {
  function getSelectionRange(position) {
    const applicableRanges = getApplicableRanges(position);
    let current = void 0;
    for (let index = applicableRanges.length - 1; index >= 0; index--) {
      current = SelectionRange.create(Range.create(
        document.positionAt(applicableRanges[index][0]),
        document.positionAt(applicableRanges[index][1])
      ), current);
    }
    if (!current) {
      current = SelectionRange.create(Range.create(position, position));
    }
    return current;
  }
  return positions.map(getSelectionRange);
  function getApplicableRanges(position) {
    const offset = document.offsetAt(position);
    let currNode = stylesheet.findChildAtOffset(offset, true);
    if (!currNode) {
      return [];
    }
    const result = [];
    while (currNode) {
      if (currNode.parent && currNode.offset === currNode.parent.offset && currNode.end === currNode.parent.end) {
        currNode = currNode.parent;
        continue;
      }
      if (currNode.type === 20 /* Declarations */) {
        if (offset > currNode.offset && offset < currNode.end) {
          result.push([currNode.offset + 1, currNode.end - 1]);
        }
      }
      result.push([currNode.offset, currNode.end]);
      currNode = currNode.parent;
    }
    return result;
  }
}

// src/vscode-css-languageservice/parser/cssErrors.ts
import * as nls6 from "vscode-nls";
var localize6 = nls6.loadMessageBundle();
var CSSIssueType = class {
  constructor(id, message) {
    this.id = id;
    this.message = message;
  }
};
var ParseError = {
  NumberExpected: new CSSIssueType("css-numberexpected", localize6("expected.number", "number expected")),
  ConditionExpected: new CSSIssueType("css-conditionexpected", localize6("expected.condt", "condition expected")),
  RuleOrSelectorExpected: new CSSIssueType("css-ruleorselectorexpected", localize6("expected.ruleorselector", "at-rule or selector expected")),
  DotExpected: new CSSIssueType("css-dotexpected", localize6("expected.dot", "dot expected")),
  ColonExpected: new CSSIssueType("css-colonexpected", localize6("expected.colon", "colon expected")),
  SemiColonExpected: new CSSIssueType("css-semicolonexpected", localize6("expected.semicolon", "semi-colon expected")),
  TermExpected: new CSSIssueType("css-termexpected", localize6("expected.term", "term expected")),
  ExpressionExpected: new CSSIssueType("css-expressionexpected", localize6("expected.expression", "expression expected")),
  OperatorExpected: new CSSIssueType("css-operatorexpected", localize6("expected.operator", "operator expected")),
  IdentifierExpected: new CSSIssueType("css-identifierexpected", localize6("expected.ident", "identifier expected")),
  PercentageExpected: new CSSIssueType("css-percentageexpected", localize6("expected.percentage", "percentage expected")),
  URIOrStringExpected: new CSSIssueType("css-uriorstringexpected", localize6("expected.uriorstring", "uri or string expected")),
  URIExpected: new CSSIssueType("css-uriexpected", localize6("expected.uri", "URI expected")),
  VariableNameExpected: new CSSIssueType("css-varnameexpected", localize6("expected.varname", "variable name expected")),
  VariableValueExpected: new CSSIssueType("css-varvalueexpected", localize6("expected.varvalue", "variable value expected")),
  PropertyValueExpected: new CSSIssueType("css-propertyvalueexpected", localize6("expected.propvalue", "property value expected")),
  LeftCurlyExpected: new CSSIssueType("css-lcurlyexpected", localize6("expected.lcurly", "{ expected")),
  RightCurlyExpected: new CSSIssueType("css-rcurlyexpected", localize6("expected.rcurly", "} expected")),
  LeftSquareBracketExpected: new CSSIssueType("css-rbracketexpected", localize6("expected.lsquare", "[ expected")),
  RightSquareBracketExpected: new CSSIssueType("css-lbracketexpected", localize6("expected.rsquare", "] expected")),
  LeftParenthesisExpected: new CSSIssueType("css-lparentexpected", localize6("expected.lparen", "( expected")),
  RightParenthesisExpected: new CSSIssueType("css-rparentexpected", localize6("expected.rparent", ") expected")),
  CommaExpected: new CSSIssueType("css-commaexpected", localize6("expected.comma", "comma expected")),
  PageDirectiveOrDeclarationExpected: new CSSIssueType("css-pagedirordeclexpected", localize6("expected.pagedirordecl", "page directive or declaraton expected")),
  UnknownAtRule: new CSSIssueType("css-unknownatrule", localize6("unknown.atrule", "at-rule unknown")),
  UnknownKeyword: new CSSIssueType("css-unknownkeyword", localize6("unknown.keyword", "unknown keyword")),
  SelectorExpected: new CSSIssueType("css-selectorexpected", localize6("expected.selector", "selector expected")),
  StringLiteralExpected: new CSSIssueType("css-stringliteralexpected", localize6("expected.stringliteral", "string literal expected")),
  WhitespaceExpected: new CSSIssueType("css-whitespaceexpected", localize6("expected.whitespace", "whitespace expected")),
  MediaQueryExpected: new CSSIssueType("css-mediaqueryexpected", localize6("expected.mediaquery", "media query expected")),
  IdentifierOrWildcardExpected: new CSSIssueType("css-idorwildcardexpected", localize6("expected.idorwildcard", "identifier or wildcard expected")),
  WildcardExpected: new CSSIssueType("css-wildcardexpected", localize6("expected.wildcard", "wildcard expected")),
  IdentifierOrVariableExpected: new CSSIssueType("css-idorvarexpected", localize6("expected.idorvar", "identifier or variable expected"))
};

// src/vscode-css-languageservice/parser/cssParser.ts
var Parser = class {
  constructor(scnr = new Scanner()) {
    this.keyframeRegex = /^@(\-(webkit|ms|moz|o)\-)?keyframes$/i;
    this.scanner = scnr;
    this.token = { type: 41 /* EOF */, offset: -1, len: 0, text: "" };
    this.prevToken = void 0;
  }
  peekIdent(text) {
    return 0 /* Ident */ === this.token.type && text.length === this.token.text.length && text === this.token.text.toLowerCase();
  }
  peekKeyword(text) {
    return 1 /* AtKeyword */ === this.token.type && text.length === this.token.text.length && text === this.token.text.toLowerCase();
  }
  peekDelim(text) {
    return 26 /* Delim */ === this.token.type && text === this.token.text;
  }
  peek(type) {
    return type === this.token.type;
  }
  peekOne(...types) {
    return types.indexOf(this.token.type) !== -1;
  }
  peekRegExp(type, regEx) {
    if (type !== this.token.type) {
      return false;
    }
    return regEx.test(this.token.text);
  }
  hasWhitespace() {
    return !!this.prevToken && this.prevToken.offset + this.prevToken.len !== this.token.offset;
  }
  consumeToken() {
    this.prevToken = this.token;
    this.token = this.scanner.scan();
  }
  acceptUnicodeRange() {
    const token = this.scanner.tryScanUnicode();
    if (token) {
      this.prevToken = token;
      this.token = this.scanner.scan();
      return true;
    }
    return false;
  }
  mark() {
    return {
      prev: this.prevToken,
      curr: this.token,
      pos: this.scanner.pos()
    };
  }
  restoreAtMark(mark) {
    this.prevToken = mark.prev;
    this.token = mark.curr;
    this.scanner.goBackTo(mark.pos);
  }
  try(func) {
    const pos = this.mark();
    const node = func();
    if (!node) {
      this.restoreAtMark(pos);
      return null;
    }
    return node;
  }
  acceptOneKeyword(keywords) {
    if (1 /* AtKeyword */ === this.token.type) {
      for (const keyword of keywords) {
        if (keyword.length === this.token.text.length && keyword === this.token.text.toLowerCase()) {
          this.consumeToken();
          return true;
        }
      }
    }
    return false;
  }
  accept(type) {
    if (type === this.token.type) {
      this.consumeToken();
      return true;
    }
    return false;
  }
  acceptIdent(text) {
    if (this.peekIdent(text)) {
      this.consumeToken();
      return true;
    }
    return false;
  }
  acceptKeyword(text) {
    if (this.peekKeyword(text)) {
      this.consumeToken();
      return true;
    }
    return false;
  }
  acceptDelim(text) {
    if (this.peekDelim(text)) {
      this.consumeToken();
      return true;
    }
    return false;
  }
  acceptRegexp(regEx) {
    if (regEx.test(this.token.text)) {
      this.consumeToken();
      return true;
    }
    return false;
  }
  _parseRegexp(regEx) {
    const node = this.createNode(1 /* Identifier */);
    do {
    } while (this.acceptRegexp(regEx));
    return this.finish(node);
  }
  acceptUnquotedString() {
    const pos = this.scanner.pos();
    this.scanner.goBackTo(this.token.offset);
    const unquoted = this.scanner.scanUnquotedString();
    if (unquoted) {
      this.token = unquoted;
      this.consumeToken();
      return true;
    }
    this.scanner.goBackTo(pos);
    return false;
  }
  resync(resyncTokens, resyncStopTokens) {
    while (true) {
      if (resyncTokens && resyncTokens.indexOf(this.token.type) !== -1) {
        this.consumeToken();
        return true;
      } else if (resyncStopTokens && resyncStopTokens.indexOf(this.token.type) !== -1) {
        return true;
      } else {
        if (this.token.type === 41 /* EOF */) {
          return false;
        }
        this.token = this.scanner.scan();
      }
    }
  }
  createNode(nodeType) {
    return new Node(this.token.offset, this.token.len, nodeType);
  }
  create(ctor) {
    return new ctor(this.token.offset, this.token.len);
  }
  finish(node, error, resyncTokens, resyncStopTokens) {
    if (!(node instanceof Nodelist)) {
      if (error) {
        this.markError(node, error, resyncTokens, resyncStopTokens);
      }
      if (this.prevToken) {
        const prevEnd = this.prevToken.offset + this.prevToken.len;
        node.length = prevEnd > node.offset ? prevEnd - node.offset : 0;
      }
    }
    return node;
  }
  markError(node, error, resyncTokens, resyncStopTokens) {
    if (this.token !== this.lastErrorToken) {
      node.addIssue(new Marker(node, error, 4 /* Error */, void 0, this.token.offset, this.token.len));
      this.lastErrorToken = this.token;
    }
    if (resyncTokens || resyncStopTokens) {
      this.resync(resyncTokens, resyncStopTokens);
    }
  }
  parseStylesheet(textDocument) {
    const versionId = textDocument.version;
    const text = textDocument.getText();
    const textProvider = (offset, length) => {
      if (textDocument.version !== versionId) {
        throw new Error("Underlying model has changed, AST is no longer valid");
      }
      return text.substr(offset, length);
    };
    return this.internalParse(text, this._parseStylesheet, textProvider);
  }
  internalParse(input, parseFunc, textProvider) {
    this.scanner.setSource(input);
    this.token = this.scanner.scan();
    const node = parseFunc.bind(this)();
    if (node) {
      if (textProvider) {
        node.textProvider = textProvider;
      } else {
        node.textProvider = (offset, length) => {
          return input.substr(offset, length);
        };
      }
    }
    return node;
  }
  _parseStylesheet() {
    const node = this.create(Stylesheet);
    while (node.addChild(this._parseStylesheetStart())) {
    }
    let inRecovery = false;
    do {
      let hasMatch = false;
      do {
        hasMatch = false;
        const statement = this._parseStylesheetStatement();
        if (statement) {
          node.addChild(statement);
          hasMatch = true;
          inRecovery = false;
          if (!this.peek(41 /* EOF */) && this._needsSemicolonAfter(statement) && !this.accept(13 /* SemiColon */)) {
            this.markError(node, ParseError.SemiColonExpected);
          }
        }
        while (this.accept(13 /* SemiColon */) || this.accept(10 /* CDO */) || this.accept(11 /* CDC */)) {
          hasMatch = true;
          inRecovery = false;
        }
      } while (hasMatch);
      if (this.peek(41 /* EOF */)) {
        break;
      }
      if (!inRecovery) {
        if (this.peek(1 /* AtKeyword */)) {
          this.markError(node, ParseError.UnknownAtRule);
        } else {
          this.markError(node, ParseError.RuleOrSelectorExpected);
        }
        inRecovery = true;
      }
      this.consumeToken();
    } while (!this.peek(41 /* EOF */));
    return this.finish(node);
  }
  _parseStylesheetStart() {
    return this._parseCharset();
  }
  _parseStylesheetStatement(isNested = false) {
    if (this.peek(1 /* AtKeyword */)) {
      return this._parseStylesheetAtStatement(isNested);
    }
    return this._parseRuleset(isNested);
  }
  _parseStylesheetAtStatement(isNested = false) {
    return this._parseImport() || this._parseMedia(isNested) || this._parsePage() || this._parseFontFace() || this._parseKeyframe() || this._parseSupports(isNested) || this._parseLayer() || this._parseViewPort() || this._parseNamespace() || this._parseDocument() || this._parseUnknownAtRule();
  }
  _tryParseRuleset(isNested) {
    const mark = this.mark();
    if (this._parseSelector(isNested)) {
      while (this.accept(35 /* Comma */) && this._parseSelector(isNested)) {
      }
      if (this.accept(14 /* CurlyL */)) {
        this.restoreAtMark(mark);
        return this._parseRuleset(isNested);
      }
    }
    this.restoreAtMark(mark);
    return null;
  }
  _parseRuleset(isNested = false) {
    const node = this.create(RuleSet);
    const selectors = node.getSelectors();
    if (!selectors.addChild(this._parseSelector(isNested))) {
      return null;
    }
    while (this.accept(35 /* Comma */)) {
      if (!selectors.addChild(this._parseSelector(isNested))) {
        return this.finish(node, ParseError.SelectorExpected);
      }
    }
    return this._parseBody(node, this._parseRuleSetDeclaration.bind(this));
  }
  _parseRuleSetDeclarationAtStatement() {
    return this._parseUnknownAtRule();
  }
  _parseRuleSetDeclaration() {
    if (this.peek(1 /* AtKeyword */)) {
      return this._parseRuleSetDeclarationAtStatement();
    }
    return this._parseDeclaration();
  }
  _needsSemicolonAfter(node) {
    switch (node.type) {
      case 52 /* Keyframe */:
      case 65 /* ViewPort */:
      case 51 /* Media */:
      case 3 /* Ruleset */:
      case 55 /* Namespace */:
      case 44 /* If */:
      case 46 /* For */:
      case 47 /* Each */:
      case 48 /* While */:
      case 34 /* MixinDeclaration */:
      case 57 /* FunctionDeclaration */:
      case 50 /* MixinContentDeclaration */:
        return false;
      case 41 /* ExtendsReference */:
      case 49 /* MixinContentReference */:
      case 58 /* ReturnStatement */:
      case 59 /* MediaQuery */:
      case 43 /* Debug */:
      case 54 /* Import */:
      case 67 /* AtApplyRule */:
      case 68 /* CustomPropertyDeclaration */:
        return true;
      case 37 /* VariableDeclaration */:
        return node.needsSemicolon;
      case 35 /* MixinReference */:
        return !node.getContent();
      case 19 /* Declaration */:
        return !node.getNestedProperties();
    }
    return false;
  }
  _parseDeclarations(parseDeclaration) {
    const node = this.create(Declarations);
    if (!this.accept(14 /* CurlyL */)) {
      return null;
    }
    let decl = parseDeclaration();
    while (node.addChild(decl)) {
      if (this.peek(15 /* CurlyR */)) {
        break;
      }
      if (this._needsSemicolonAfter(decl) && !this.accept(13 /* SemiColon */)) {
        return this.finish(node, ParseError.SemiColonExpected, [13 /* SemiColon */, 15 /* CurlyR */]);
      }
      if (decl && this.prevToken && this.prevToken.type === 13 /* SemiColon */) {
        decl.semicolonPosition = this.prevToken.offset;
      }
      while (this.accept(13 /* SemiColon */)) {
      }
      decl = parseDeclaration();
    }
    if (!this.accept(15 /* CurlyR */)) {
      return this.finish(node, ParseError.RightCurlyExpected, [15 /* CurlyR */, 13 /* SemiColon */]);
    }
    return this.finish(node);
  }
  _parseBody(node, parseDeclaration) {
    if (!node.setDeclarations(this._parseDeclarations(parseDeclaration))) {
      return this.finish(node, ParseError.LeftCurlyExpected, [15 /* CurlyR */, 13 /* SemiColon */]);
    }
    return this.finish(node);
  }
  _parseSelector(isNested) {
    const node = this.create(Selector);
    let hasContent = false;
    if (isNested) {
      hasContent = node.addChild(this._parseCombinator());
    }
    while (node.addChild(this._parseSimpleSelector())) {
      hasContent = true;
      node.addChild(this._parseCombinator());
    }
    return hasContent ? this.finish(node) : null;
  }
  _parseDeclaration(stopTokens) {
    const custonProperty = this._tryParseCustomPropertyDeclaration(stopTokens);
    if (custonProperty) {
      return custonProperty;
    }
    const node = this.create(Declaration);
    if (!node.setProperty(this._parseProperty())) {
      return null;
    }
    if (!this.accept(12 /* Colon */)) {
      return this.finish(node, ParseError.ColonExpected, [12 /* Colon */], stopTokens || [13 /* SemiColon */]);
    }
    if (this.prevToken) {
      node.colonPosition = this.prevToken.offset;
    }
    if (!node.setValue(this._parseExpr())) {
      return this.finish(node, ParseError.PropertyValueExpected);
    }
    node.addChild(this._parsePrio());
    if (this.peek(13 /* SemiColon */)) {
      node.semicolonPosition = this.token.offset;
    }
    return this.finish(node);
  }
  _tryParseCustomPropertyDeclaration(stopTokens) {
    if (!this.peekRegExp(0 /* Ident */, /^--/)) {
      return null;
    }
    const node = this.create(CustomPropertyDeclaration);
    if (!node.setProperty(this._parseProperty())) {
      return null;
    }
    if (!this.accept(12 /* Colon */)) {
      return this.finish(node, ParseError.ColonExpected, [12 /* Colon */]);
    }
    if (this.prevToken) {
      node.colonPosition = this.prevToken.offset;
    }
    const mark = this.mark();
    if (this.peek(14 /* CurlyL */)) {
      const propertySet = this.create(CustomPropertySet);
      const declarations = this._parseDeclarations(this._parseRuleSetDeclaration.bind(this));
      if (propertySet.setDeclarations(declarations) && !declarations.isErroneous(true)) {
        propertySet.addChild(this._parsePrio());
        if (this.peek(13 /* SemiColon */)) {
          this.finish(propertySet);
          node.setPropertySet(propertySet);
          node.semicolonPosition = this.token.offset;
          return this.finish(node);
        }
      }
      this.restoreAtMark(mark);
    }
    const expression = this._parseExpr();
    if (expression && !expression.isErroneous(true)) {
      this._parsePrio();
      if (this.peekOne(...stopTokens || [], 13 /* SemiColon */, 41 /* EOF */)) {
        node.setValue(expression);
        if (this.peek(13 /* SemiColon */)) {
          node.semicolonPosition = this.token.offset;
        }
        return this.finish(node);
      }
    }
    this.restoreAtMark(mark);
    node.addChild(this._parseCustomPropertyValue(stopTokens));
    node.addChild(this._parsePrio());
    if (isDefined(node.colonPosition) && this.token.offset === node.colonPosition + 1) {
      return this.finish(node, ParseError.PropertyValueExpected);
    }
    return this.finish(node);
  }
  _parseCustomPropertyValue(stopTokens = [15 /* CurlyR */]) {
    const node = this.create(Node);
    const isTopLevel = () => curlyDepth === 0 && parensDepth === 0 && bracketsDepth === 0;
    const onStopToken = () => stopTokens.indexOf(this.token.type) !== -1;
    let curlyDepth = 0;
    let parensDepth = 0;
    let bracketsDepth = 0;
    done:
      while (true) {
        switch (this.token.type) {
          case 13 /* SemiColon */:
            if (isTopLevel()) {
              break done;
            }
            break;
          case 33 /* Exclamation */:
            if (isTopLevel()) {
              break done;
            }
            break;
          case 14 /* CurlyL */:
            curlyDepth++;
            break;
          case 15 /* CurlyR */:
            curlyDepth--;
            if (curlyDepth < 0) {
              if (onStopToken() && parensDepth === 0 && bracketsDepth === 0) {
                break done;
              }
              return this.finish(node, ParseError.LeftCurlyExpected);
            }
            break;
          case 16 /* ParenthesisL */:
            parensDepth++;
            break;
          case 17 /* ParenthesisR */:
            parensDepth--;
            if (parensDepth < 0) {
              if (onStopToken() && bracketsDepth === 0 && curlyDepth === 0) {
                break done;
              }
              return this.finish(node, ParseError.LeftParenthesisExpected);
            }
            break;
          case 18 /* BracketL */:
            bracketsDepth++;
            break;
          case 19 /* BracketR */:
            bracketsDepth--;
            if (bracketsDepth < 0) {
              return this.finish(node, ParseError.LeftSquareBracketExpected);
            }
            break;
          case 3 /* BadString */:
            break done;
          case 41 /* EOF */:
            let error = ParseError.RightCurlyExpected;
            if (bracketsDepth > 0) {
              error = ParseError.RightSquareBracketExpected;
            } else if (parensDepth > 0) {
              error = ParseError.RightParenthesisExpected;
            }
            return this.finish(node, error);
        }
        this.consumeToken();
      }
    return this.finish(node);
  }
  _tryToParseDeclaration(stopTokens) {
    const mark = this.mark();
    if (this._parseProperty() && this.accept(12 /* Colon */)) {
      this.restoreAtMark(mark);
      return this._parseDeclaration(stopTokens);
    }
    this.restoreAtMark(mark);
    return null;
  }
  _parseProperty() {
    const node = this.create(Property);
    const mark = this.mark();
    if (this.acceptDelim("*") || this.acceptDelim("_")) {
      if (this.hasWhitespace()) {
        this.restoreAtMark(mark);
        return null;
      }
    }
    if (node.setIdentifier(this._parsePropertyIdentifier())) {
      return this.finish(node);
    }
    return null;
  }
  _parsePropertyIdentifier() {
    return this._parseIdent();
  }
  _parseCharset() {
    if (!this.peek(36 /* Charset */)) {
      return null;
    }
    const node = this.create(Node);
    this.consumeToken();
    if (!this.accept(2 /* String */)) {
      return this.finish(node, ParseError.IdentifierExpected);
    }
    if (!this.accept(13 /* SemiColon */)) {
      return this.finish(node, ParseError.SemiColonExpected);
    }
    return this.finish(node);
  }
  _parseImport() {
    if (!this.peekKeyword("@import")) {
      return null;
    }
    const node = this.create(Import);
    this.consumeToken();
    if (!node.addChild(this._parseURILiteral()) && !node.addChild(this._parseStringLiteral())) {
      return this.finish(node, ParseError.URIOrStringExpected);
    }
    if (this.acceptIdent("layer")) {
      if (this.accept(16 /* ParenthesisL */)) {
        if (!node.addChild(this._parseLayerName())) {
          return this.finish(node, ParseError.IdentifierExpected, [13 /* SemiColon */]);
        }
        if (!this.accept(17 /* ParenthesisR */)) {
          return this.finish(node, ParseError.RightParenthesisExpected, [17 /* ParenthesisR */], []);
        }
      }
    }
    if (this.acceptIdent("supports")) {
      if (this.accept(16 /* ParenthesisL */)) {
        node.addChild(this._tryToParseDeclaration() || this._parseSupportsCondition());
        if (!this.accept(17 /* ParenthesisR */)) {
          return this.finish(node, ParseError.RightParenthesisExpected, [17 /* ParenthesisR */], []);
        }
      }
    }
    if (!this.peek(13 /* SemiColon */) && !this.peek(41 /* EOF */)) {
      node.setMedialist(this._parseMediaQueryList());
    }
    return this.finish(node);
  }
  _parseNamespace() {
    if (!this.peekKeyword("@namespace")) {
      return null;
    }
    const node = this.create(Namespace);
    this.consumeToken();
    if (!node.addChild(this._parseURILiteral())) {
      node.addChild(this._parseIdent());
      if (!node.addChild(this._parseURILiteral()) && !node.addChild(this._parseStringLiteral())) {
        return this.finish(node, ParseError.URIExpected, [13 /* SemiColon */]);
      }
    }
    if (!this.accept(13 /* SemiColon */)) {
      return this.finish(node, ParseError.SemiColonExpected);
    }
    return this.finish(node);
  }
  _parseFontFace() {
    if (!this.peekKeyword("@font-face")) {
      return null;
    }
    const node = this.create(FontFace);
    this.consumeToken();
    return this._parseBody(node, this._parseRuleSetDeclaration.bind(this));
  }
  _parseViewPort() {
    if (!this.peekKeyword("@-ms-viewport") && !this.peekKeyword("@-o-viewport") && !this.peekKeyword("@viewport")) {
      return null;
    }
    const node = this.create(ViewPort);
    this.consumeToken();
    return this._parseBody(node, this._parseRuleSetDeclaration.bind(this));
  }
  _parseKeyframe() {
    if (!this.peekRegExp(1 /* AtKeyword */, this.keyframeRegex)) {
      return null;
    }
    const node = this.create(Keyframe);
    const atNode = this.create(Node);
    this.consumeToken();
    node.setKeyword(this.finish(atNode));
    if (atNode.matches("@-ms-keyframes")) {
      this.markError(atNode, ParseError.UnknownKeyword);
    }
    if (!node.setIdentifier(this._parseKeyframeIdent())) {
      return this.finish(node, ParseError.IdentifierExpected, [15 /* CurlyR */]);
    }
    return this._parseBody(node, this._parseKeyframeSelector.bind(this));
  }
  _parseKeyframeIdent() {
    return this._parseIdent([4 /* Keyframe */]);
  }
  _parseKeyframeSelector() {
    const node = this.create(KeyframeSelector);
    if (!node.addChild(this._parseIdent()) && !this.accept(7 /* Percentage */)) {
      return null;
    }
    while (this.accept(35 /* Comma */)) {
      if (!node.addChild(this._parseIdent()) && !this.accept(7 /* Percentage */)) {
        return this.finish(node, ParseError.PercentageExpected);
      }
    }
    return this._parseBody(node, this._parseRuleSetDeclaration.bind(this));
  }
  _tryParseKeyframeSelector() {
    const node = this.create(KeyframeSelector);
    const pos = this.mark();
    if (!node.addChild(this._parseIdent()) && !this.accept(7 /* Percentage */)) {
      return null;
    }
    while (this.accept(35 /* Comma */)) {
      if (!node.addChild(this._parseIdent()) && !this.accept(7 /* Percentage */)) {
        this.restoreAtMark(pos);
        return null;
      }
    }
    if (!this.peek(14 /* CurlyL */)) {
      this.restoreAtMark(pos);
      return null;
    }
    return this._parseBody(node, this._parseRuleSetDeclaration.bind(this));
  }
  _parseLayer() {
    if (!this.peekKeyword("@layer")) {
      return null;
    }
    const node = this.create(Layer);
    this.consumeToken();
    const names = this._parseLayerNameList();
    if (names) {
      node.setNames(names);
    }
    if ((!names || names.getChildren().length === 1) && this.peek(14 /* CurlyL */)) {
      return this._parseBody(node, this._parseStylesheetStatement.bind(this));
    }
    if (!this.accept(13 /* SemiColon */)) {
      return this.finish(node, ParseError.SemiColonExpected);
    }
    return this.finish(node);
  }
  _parseLayerNameList() {
    const node = this.createNode(84 /* LayerNameList */);
    if (!node.addChild(this._parseLayerName())) {
      return null;
    }
    while (this.accept(35 /* Comma */)) {
      if (!node.addChild(this._parseLayerName())) {
        return this.finish(node, ParseError.IdentifierExpected);
      }
    }
    return this.finish(node);
  }
  _parseLayerName() {
    if (!this.peek(0 /* Ident */)) {
      return null;
    }
    const node = this.createNode(85 /* LayerName */);
    node.addChild(this._parseIdent());
    while (!this.hasWhitespace() && this.acceptDelim(".")) {
      if (this.hasWhitespace() || !node.addChild(this._parseIdent())) {
        return this.finish(node, ParseError.IdentifierExpected);
      }
    }
    return this.finish(node);
  }
  _parseSupports(isNested = false) {
    if (!this.peekKeyword("@supports")) {
      return null;
    }
    const node = this.create(Supports);
    this.consumeToken();
    node.addChild(this._parseSupportsCondition());
    return this._parseBody(node, this._parseSupportsDeclaration.bind(this, isNested));
  }
  _parseSupportsDeclaration(isNested = false) {
    if (isNested) {
      return this._tryParseRuleset(true) || this._tryToParseDeclaration() || this._parseStylesheetStatement(true);
    }
    return this._parseStylesheetStatement(false);
  }
  _parseSupportsCondition() {
    const node = this.create(SupportsCondition);
    if (this.acceptIdent("not")) {
      node.addChild(this._parseSupportsConditionInParens());
    } else {
      node.addChild(this._parseSupportsConditionInParens());
      if (this.peekRegExp(0 /* Ident */, /^(and|or)$/i)) {
        const text = this.token.text.toLowerCase();
        while (this.acceptIdent(text)) {
          node.addChild(this._parseSupportsConditionInParens());
        }
      }
    }
    return this.finish(node);
  }
  _parseSupportsConditionInParens() {
    const node = this.create(SupportsCondition);
    if (this.accept(16 /* ParenthesisL */)) {
      if (this.prevToken) {
        node.lParent = this.prevToken.offset;
      }
      if (!node.addChild(this._tryToParseDeclaration([17 /* ParenthesisR */]))) {
        if (!this._parseSupportsCondition()) {
          return this.finish(node, ParseError.ConditionExpected);
        }
      }
      if (!this.accept(17 /* ParenthesisR */)) {
        return this.finish(node, ParseError.RightParenthesisExpected, [17 /* ParenthesisR */], []);
      }
      if (this.prevToken) {
        node.rParent = this.prevToken.offset;
      }
      return this.finish(node);
    } else if (this.peek(0 /* Ident */)) {
      const pos = this.mark();
      this.consumeToken();
      if (!this.hasWhitespace() && this.accept(16 /* ParenthesisL */)) {
        let openParentCount = 1;
        while (this.token.type !== 41 /* EOF */ && openParentCount !== 0) {
          if (this.token.type === 16 /* ParenthesisL */) {
            openParentCount++;
          } else if (this.token.type === 17 /* ParenthesisR */) {
            openParentCount--;
          }
          this.consumeToken();
        }
        return this.finish(node);
      } else {
        this.restoreAtMark(pos);
      }
    }
    return this.finish(node, ParseError.LeftParenthesisExpected, [], [16 /* ParenthesisL */]);
  }
  _parseMediaDeclaration(isNested = false) {
    if (isNested) {
      return this._tryParseRuleset(true) || this._tryToParseDeclaration() || this._parseStylesheetStatement(true);
    }
    return this._parseStylesheetStatement(false);
  }
  _parseMedia(isNested = false) {
    if (!this.peekKeyword("@media")) {
      return null;
    }
    const node = this.create(Media);
    this.consumeToken();
    if (!node.addChild(this._parseMediaQueryList())) {
      return this.finish(node, ParseError.MediaQueryExpected);
    }
    return this._parseBody(node, this._parseMediaDeclaration.bind(this, isNested));
  }
  _parseMediaQueryList() {
    const node = this.create(Medialist);
    if (!node.addChild(this._parseMediaQuery())) {
      return this.finish(node, ParseError.MediaQueryExpected);
    }
    while (this.accept(35 /* Comma */)) {
      if (!node.addChild(this._parseMediaQuery())) {
        return this.finish(node, ParseError.MediaQueryExpected);
      }
    }
    return this.finish(node);
  }
  _parseMediaQuery() {
    const node = this.create(MediaQuery);
    const pos = this.mark();
    this.acceptIdent("not");
    if (!this.peek(16 /* ParenthesisL */)) {
      if (this.acceptIdent("only")) {
      }
      if (!node.addChild(this._parseIdent())) {
        return null;
      }
      if (this.acceptIdent("and")) {
        node.addChild(this._parseMediaCondition());
      }
    } else {
      this.restoreAtMark(pos);
      node.addChild(this._parseMediaCondition());
    }
    return this.finish(node);
  }
  _parseRatio() {
    const pos = this.mark();
    const node = this.create(RatioValue);
    if (!this._parseNumeric()) {
      return null;
    }
    if (!this.acceptDelim("/")) {
      this.restoreAtMark(pos);
      return null;
    }
    if (!this._parseNumeric()) {
      return this.finish(node, ParseError.NumberExpected);
    }
    return this.finish(node);
  }
  _parseMediaCondition() {
    const node = this.create(MediaCondition);
    this.acceptIdent("not");
    let parseExpression = true;
    while (parseExpression) {
      if (!this.accept(16 /* ParenthesisL */)) {
        return this.finish(node, ParseError.LeftParenthesisExpected, [], [14 /* CurlyL */]);
      }
      if (this.peek(16 /* ParenthesisL */) || this.peekIdent("not")) {
        node.addChild(this._parseMediaCondition());
      } else {
        node.addChild(this._parseMediaFeature());
      }
      if (!this.accept(17 /* ParenthesisR */)) {
        return this.finish(node, ParseError.RightParenthesisExpected, [], [14 /* CurlyL */]);
      }
      parseExpression = this.acceptIdent("and") || this.acceptIdent("or");
    }
    return this.finish(node);
  }
  _parseMediaFeature() {
    const resyncStopToken = [17 /* ParenthesisR */];
    const node = this.create(MediaFeature);
    const parseRangeOperator = () => {
      if (this.acceptDelim("<") || this.acceptDelim(">")) {
        if (!this.hasWhitespace()) {
          this.acceptDelim("=");
        }
        return true;
      } else if (this.acceptDelim("=")) {
        return true;
      }
      return false;
    };
    if (node.addChild(this._parseMediaFeatureName())) {
      if (this.accept(12 /* Colon */)) {
        if (!node.addChild(this._parseMediaFeatureValue())) {
          return this.finish(node, ParseError.TermExpected, [], resyncStopToken);
        }
      } else if (parseRangeOperator()) {
        if (!node.addChild(this._parseMediaFeatureValue())) {
          return this.finish(node, ParseError.TermExpected, [], resyncStopToken);
        }
        if (parseRangeOperator()) {
          if (!node.addChild(this._parseMediaFeatureValue())) {
            return this.finish(node, ParseError.TermExpected, [], resyncStopToken);
          }
        }
      } else {
      }
    } else if (node.addChild(this._parseMediaFeatureValue())) {
      if (!parseRangeOperator()) {
        return this.finish(node, ParseError.OperatorExpected, [], resyncStopToken);
      }
      if (!node.addChild(this._parseMediaFeatureName())) {
        return this.finish(node, ParseError.IdentifierExpected, [], resyncStopToken);
      }
      if (parseRangeOperator()) {
        if (!node.addChild(this._parseMediaFeatureValue())) {
          return this.finish(node, ParseError.TermExpected, [], resyncStopToken);
        }
      }
    } else {
      return this.finish(node, ParseError.IdentifierExpected, [], resyncStopToken);
    }
    return this.finish(node);
  }
  _parseMediaFeatureName() {
    return this._parseIdent();
  }
  _parseMediaFeatureValue() {
    return this._parseRatio() || this._parseTermExpression();
  }
  _parseMedium() {
    const node = this.create(Node);
    if (node.addChild(this._parseIdent())) {
      return this.finish(node);
    } else {
      return null;
    }
  }
  _parsePageDeclaration() {
    return this._parsePageMarginBox() || this._parseRuleSetDeclaration();
  }
  _parsePage() {
    if (!this.peekKeyword("@page")) {
      return null;
    }
    const node = this.create(Page);
    this.consumeToken();
    if (node.addChild(this._parsePageSelector())) {
      while (this.accept(35 /* Comma */)) {
        if (!node.addChild(this._parsePageSelector())) {
          return this.finish(node, ParseError.IdentifierExpected);
        }
      }
    }
    return this._parseBody(node, this._parsePageDeclaration.bind(this));
  }
  _parsePageMarginBox() {
    if (!this.peek(1 /* AtKeyword */)) {
      return null;
    }
    const node = this.create(PageBoxMarginBox);
    if (!this.acceptOneKeyword(pageBoxDirectives)) {
      this.markError(node, ParseError.UnknownAtRule, [], [14 /* CurlyL */]);
    }
    return this._parseBody(node, this._parseRuleSetDeclaration.bind(this));
  }
  _parsePageSelector() {
    if (!this.peek(0 /* Ident */) && !this.peek(12 /* Colon */)) {
      return null;
    }
    const node = this.create(Node);
    node.addChild(this._parseIdent());
    if (this.accept(12 /* Colon */)) {
      if (!node.addChild(this._parseIdent())) {
        return this.finish(node, ParseError.IdentifierExpected);
      }
    }
    return this.finish(node);
  }
  _parseDocument() {
    if (!this.peekKeyword("@-moz-document")) {
      return null;
    }
    const node = this.create(Document);
    this.consumeToken();
    this.resync([], [14 /* CurlyL */]);
    return this._parseBody(node, this._parseStylesheetStatement.bind(this));
  }
  _parseUnknownAtRule() {
    if (!this.peek(1 /* AtKeyword */)) {
      return null;
    }
    const node = this.create(UnknownAtRule);
    node.addChild(this._parseUnknownAtRuleName());
    const isTopLevel = () => curlyDepth === 0 && parensDepth === 0 && bracketsDepth === 0;
    let curlyLCount = 0;
    let curlyDepth = 0;
    let parensDepth = 0;
    let bracketsDepth = 0;
    done:
      while (true) {
        switch (this.token.type) {
          case 13 /* SemiColon */:
            if (isTopLevel()) {
              break done;
            }
            break;
          case 41 /* EOF */:
            if (curlyDepth > 0) {
              return this.finish(node, ParseError.RightCurlyExpected);
            } else if (bracketsDepth > 0) {
              return this.finish(node, ParseError.RightSquareBracketExpected);
            } else if (parensDepth > 0) {
              return this.finish(node, ParseError.RightParenthesisExpected);
            } else {
              return this.finish(node);
            }
          case 14 /* CurlyL */:
            curlyLCount++;
            curlyDepth++;
            break;
          case 15 /* CurlyR */:
            curlyDepth--;
            if (curlyLCount > 0 && curlyDepth === 0) {
              this.consumeToken();
              if (bracketsDepth > 0) {
                return this.finish(node, ParseError.RightSquareBracketExpected);
              } else if (parensDepth > 0) {
                return this.finish(node, ParseError.RightParenthesisExpected);
              }
              break done;
            }
            if (curlyDepth < 0) {
              if (parensDepth === 0 && bracketsDepth === 0) {
                break done;
              }
              return this.finish(node, ParseError.LeftCurlyExpected);
            }
            break;
          case 16 /* ParenthesisL */:
            parensDepth++;
            break;
          case 17 /* ParenthesisR */:
            parensDepth--;
            if (parensDepth < 0) {
              return this.finish(node, ParseError.LeftParenthesisExpected);
            }
            break;
          case 18 /* BracketL */:
            bracketsDepth++;
            break;
          case 19 /* BracketR */:
            bracketsDepth--;
            if (bracketsDepth < 0) {
              return this.finish(node, ParseError.LeftSquareBracketExpected);
            }
            break;
        }
        this.consumeToken();
      }
    return node;
  }
  _parseUnknownAtRuleName() {
    const node = this.create(Node);
    if (this.accept(1 /* AtKeyword */)) {
      return this.finish(node);
    }
    return node;
  }
  _parseOperator() {
    if (this.peekDelim("/") || this.peekDelim("*") || this.peekDelim("+") || this.peekDelim("-") || this.peek(22 /* Dashmatch */) || this.peek(21 /* Includes */) || this.peek(23 /* SubstringOperator */) || this.peek(24 /* PrefixOperator */) || this.peek(25 /* SuffixOperator */) || this.peekDelim("=")) {
      const node = this.createNode(25 /* Operator */);
      this.consumeToken();
      return this.finish(node);
    } else {
      return null;
    }
  }
  _parseUnaryOperator() {
    if (!this.peekDelim("+") && !this.peekDelim("-")) {
      return null;
    }
    const node = this.create(Node);
    this.consumeToken();
    return this.finish(node);
  }
  _parseCombinator() {
    if (this.peekDelim(">")) {
      const node = this.create(Node);
      this.consumeToken();
      const mark = this.mark();
      if (!this.hasWhitespace() && this.acceptDelim(">")) {
        if (!this.hasWhitespace() && this.acceptDelim(">")) {
          node.type = 11 /* SelectorCombinatorShadowPiercingDescendant */;
          return this.finish(node);
        }
        this.restoreAtMark(mark);
      }
      node.type = 8 /* SelectorCombinatorParent */;
      return this.finish(node);
    } else if (this.peekDelim("+")) {
      const node = this.create(Node);
      this.consumeToken();
      node.type = 9 /* SelectorCombinatorSibling */;
      return this.finish(node);
    } else if (this.peekDelim("~")) {
      const node = this.create(Node);
      this.consumeToken();
      node.type = 10 /* SelectorCombinatorAllSiblings */;
      return this.finish(node);
    } else if (this.peekDelim("/")) {
      const node = this.create(Node);
      this.consumeToken();
      const mark = this.mark();
      if (!this.hasWhitespace() && this.acceptIdent("deep") && !this.hasWhitespace() && this.acceptDelim("/")) {
        node.type = 11 /* SelectorCombinatorShadowPiercingDescendant */;
        return this.finish(node);
      }
      this.restoreAtMark(mark);
    }
    return null;
  }
  _parseSimpleSelector() {
    const node = this.create(SimpleSelector);
    let c = 0;
    if (node.addChild(this._parseElementName())) {
      c++;
    }
    while ((c === 0 || !this.hasWhitespace()) && node.addChild(this._parseSimpleSelectorBody())) {
      c++;
    }
    return c > 0 ? this.finish(node) : null;
  }
  _parseSimpleSelectorBody() {
    return this._parsePseudo() || this._parseHash() || this._parseClass() || this._parseAttrib();
  }
  _parseSelectorIdent() {
    return this._parseIdent();
  }
  _parseHash() {
    if (!this.peek(5 /* Hash */) && !this.peekDelim("#")) {
      return null;
    }
    const node = this.createNode(15 /* IdentifierSelector */);
    if (this.acceptDelim("#")) {
      if (this.hasWhitespace() || !node.addChild(this._parseSelectorIdent())) {
        return this.finish(node, ParseError.IdentifierExpected);
      }
    } else {
      this.consumeToken();
    }
    return this.finish(node);
  }
  _parseClass() {
    if (!this.peekDelim(".")) {
      return null;
    }
    const node = this.createNode(14 /* ClassSelector */);
    this.consumeToken();
    if (this.hasWhitespace() || !node.addChild(this._parseSelectorIdent())) {
      return this.finish(node, ParseError.IdentifierExpected);
    }
    return this.finish(node);
  }
  _parseElementName() {
    const pos = this.mark();
    const node = this.createNode(16 /* ElementNameSelector */);
    node.addChild(this._parseNamespacePrefix());
    if (!node.addChild(this._parseSelectorIdent()) && !this.acceptDelim("*")) {
      this.restoreAtMark(pos);
      return null;
    }
    return this.finish(node);
  }
  _parseNamespacePrefix() {
    const pos = this.mark();
    const node = this.createNode(73 /* NamespacePrefix */);
    if (!node.addChild(this._parseIdent()) && !this.acceptDelim("*")) {
    }
    if (!this.acceptDelim("|")) {
      this.restoreAtMark(pos);
      return null;
    }
    return this.finish(node);
  }
  _parseAttrib() {
    if (!this.peek(18 /* BracketL */)) {
      return null;
    }
    const node = this.create(AttributeSelector);
    this.consumeToken();
    node.setNamespacePrefix(this._parseNamespacePrefix());
    if (!node.setIdentifier(this._parseIdent())) {
      return this.finish(node, ParseError.IdentifierExpected);
    }
    if (node.setOperator(this._parseOperator())) {
      node.setValue(this._parseBinaryExpr());
      this.acceptIdent("i");
      this.acceptIdent("s");
    }
    if (!this.accept(19 /* BracketR */)) {
      return this.finish(node, ParseError.RightSquareBracketExpected);
    }
    return this.finish(node);
  }
  _parsePseudo() {
    const node = this._tryParsePseudoIdentifier();
    if (node) {
      if (!this.hasWhitespace() && this.accept(16 /* ParenthesisL */)) {
        const tryAsSelector = () => {
          const selectors = this.create(Node);
          if (!selectors.addChild(this._parseSelector(true))) {
            return null;
          }
          while (this.accept(35 /* Comma */) && selectors.addChild(this._parseSelector(true))) {
          }
          if (this.peek(17 /* ParenthesisR */)) {
            return this.finish(selectors);
          }
          return null;
        };
        node.addChild(this.try(tryAsSelector) || this._parseBinaryExpr());
        if (!this.accept(17 /* ParenthesisR */)) {
          return this.finish(node, ParseError.RightParenthesisExpected);
        }
      }
      return this.finish(node);
    }
    return null;
  }
  _tryParsePseudoIdentifier() {
    if (!this.peek(12 /* Colon */)) {
      return null;
    }
    const pos = this.mark();
    const node = this.createNode(17 /* PseudoSelector */);
    this.consumeToken();
    if (this.hasWhitespace()) {
      this.restoreAtMark(pos);
      return null;
    }
    this.accept(12 /* Colon */);
    if (this.hasWhitespace() || !node.addChild(this._parseIdent())) {
      return this.finish(node, ParseError.IdentifierExpected);
    }
    return this.finish(node);
  }
  _tryParsePrio() {
    const mark = this.mark();
    const prio = this._parsePrio();
    if (prio) {
      return prio;
    }
    this.restoreAtMark(mark);
    return null;
  }
  _parsePrio() {
    if (!this.peek(33 /* Exclamation */)) {
      return null;
    }
    const node = this.createNode(38 /* Prio */);
    if (this.accept(33 /* Exclamation */) && this.acceptIdent("important")) {
      return this.finish(node);
    }
    return null;
  }
  _parseExpr(stopOnComma = false) {
    const node = this.create(Expression);
    if (!node.addChild(this._parseBinaryExpr())) {
      return null;
    }
    while (true) {
      if (this.peek(35 /* Comma */)) {
        if (stopOnComma) {
          return this.finish(node);
        }
        this.consumeToken();
      }
      if (!node.addChild(this._parseBinaryExpr())) {
        break;
      }
    }
    return this.finish(node);
  }
  _parseUnicodeRange() {
    if (!this.peekIdent("u")) {
      return null;
    }
    const node = this.create(UnicodeRange);
    if (!this.acceptUnicodeRange()) {
      return null;
    }
    return this.finish(node);
  }
  _parseNamedLine() {
    if (!this.peek(18 /* BracketL */)) {
      return null;
    }
    const node = this.createNode(74 /* GridLine */);
    this.consumeToken();
    while (node.addChild(this._parseIdent())) {
    }
    if (!this.accept(19 /* BracketR */)) {
      return this.finish(node, ParseError.RightSquareBracketExpected);
    }
    return this.finish(node);
  }
  _parseBinaryExpr(preparsedLeft, preparsedOper) {
    let node = this.create(BinaryExpression);
    if (!node.setLeft(preparsedLeft || this._parseTerm())) {
      return null;
    }
    if (!node.setOperator(preparsedOper || this._parseOperator())) {
      return this.finish(node);
    }
    if (!node.setRight(this._parseTerm())) {
      return this.finish(node, ParseError.TermExpected);
    }
    node = this.finish(node);
    const operator = this._parseOperator();
    if (operator) {
      node = this._parseBinaryExpr(node, operator);
    }
    return this.finish(node);
  }
  _parseTerm() {
    const node = this.create(Term);
    node.setOperator(this._parseUnaryOperator());
    if (node.setExpression(this._parseTermExpression())) {
      return this.finish(node);
    }
    return null;
  }
  _parseTermExpression() {
    return this._parseURILiteral() || this._parseUnicodeRange() || this._parseFunction() || this._parseIdent() || this._parseStringLiteral() || this._parseNumeric() || this._parseHexColor() || this._parseOperation() || this._parseNamedLine();
  }
  _parseOperation() {
    if (!this.peek(16 /* ParenthesisL */)) {
      return null;
    }
    const node = this.create(Node);
    this.consumeToken();
    node.addChild(this._parseExpr());
    if (!this.accept(17 /* ParenthesisR */)) {
      return this.finish(node, ParseError.RightParenthesisExpected);
    }
    return this.finish(node);
  }
  _parseNumeric() {
    if (this.peek(6 /* Num */) || this.peek(7 /* Percentage */) || this.peek(34 /* Resolution */) || this.peek(29 /* Length */) || this.peek(27 /* EMS */) || this.peek(28 /* EXS */) || this.peek(30 /* Angle */) || this.peek(31 /* Time */) || this.peek(8 /* Dimension */) || this.peek(32 /* Freq */)) {
      const node = this.create(NumericValue);
      this.consumeToken();
      return this.finish(node);
    }
    return null;
  }
  _parseStringLiteral() {
    if (!this.peek(2 /* String */) && !this.peek(3 /* BadString */)) {
      return null;
    }
    const node = this.createNode(27 /* StringLiteral */);
    this.consumeToken();
    return this.finish(node);
  }
  _parseURILiteral() {
    if (!this.peekRegExp(0 /* Ident */, /^url(-prefix)?$/i)) {
      return null;
    }
    const pos = this.mark();
    const node = this.createNode(28 /* URILiteral */);
    this.accept(0 /* Ident */);
    if (this.hasWhitespace() || !this.peek(16 /* ParenthesisL */)) {
      this.restoreAtMark(pos);
      return null;
    }
    this.scanner.inURL = true;
    this.consumeToken();
    node.addChild(this._parseURLArgument());
    this.scanner.inURL = false;
    if (!this.accept(17 /* ParenthesisR */)) {
      return this.finish(node, ParseError.RightParenthesisExpected);
    }
    return this.finish(node);
  }
  _parseURLArgument() {
    const node = this.create(Node);
    if (!this.accept(2 /* String */) && !this.accept(3 /* BadString */) && !this.acceptUnquotedString()) {
      return null;
    }
    return this.finish(node);
  }
  _parseIdent(referenceTypes) {
    if (!this.peek(0 /* Ident */)) {
      return null;
    }
    const node = this.create(Identifier);
    if (referenceTypes) {
      node.referenceTypes = referenceTypes;
    }
    node.isCustomProperty = this.peekRegExp(0 /* Ident */, /^--/);
    this.consumeToken();
    return this.finish(node);
  }
  _parseFunction() {
    const pos = this.mark();
    const node = this.create(Function);
    if (!node.setIdentifier(this._parseFunctionIdentifier())) {
      return null;
    }
    if (this.hasWhitespace() || !this.accept(16 /* ParenthesisL */)) {
      this.restoreAtMark(pos);
      return null;
    }
    if (node.getArguments().addChild(this._parseFunctionArgument())) {
      while (this.accept(35 /* Comma */)) {
        if (this.peek(17 /* ParenthesisR */)) {
          break;
        }
        if (!node.getArguments().addChild(this._parseFunctionArgument())) {
          this.markError(node, ParseError.ExpressionExpected);
        }
      }
    }
    if (!this.accept(17 /* ParenthesisR */)) {
      return this.finish(node, ParseError.RightParenthesisExpected);
    }
    return this.finish(node);
  }
  _parseFunctionIdentifier() {
    if (!this.peek(0 /* Ident */)) {
      return null;
    }
    const node = this.create(Identifier);
    node.referenceTypes = [3 /* Function */];
    if (this.acceptIdent("progid")) {
      if (this.accept(12 /* Colon */)) {
        while (this.accept(0 /* Ident */) && this.acceptDelim(".")) {
        }
      }
      return this.finish(node);
    }
    this.consumeToken();
    return this.finish(node);
  }
  _parseFunctionArgument() {
    const node = this.create(FunctionArgument);
    if (node.setValue(this._parseExpr(true))) {
      return this.finish(node);
    }
    return null;
  }
  _parseHexColor() {
    if (this.peekRegExp(5 /* Hash */, /^#([A-Fa-f0-9]{3}|[A-Fa-f0-9]{4}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{8})$/g)) {
      const node = this.create(HexColorValue);
      this.consumeToken();
      return this.finish(node);
    } else {
      return null;
    }
  }
};

// src/vscode-css-languageservice/parser/scssErrors.ts
import * as nls7 from "vscode-nls";
var localize7 = nls7.loadMessageBundle();
var SCSSIssueType = class {
  constructor(id, message) {
    this.id = id;
    this.message = message;
  }
};
var SCSSParseError = {
  FromExpected: new SCSSIssueType("scss-fromexpected", localize7("expected.from", "'from' expected")),
  ThroughOrToExpected: new SCSSIssueType("scss-throughexpected", localize7("expected.through", "'through' or 'to' expected")),
  InExpected: new SCSSIssueType("scss-fromexpected", localize7("expected.in", "'in' expected"))
};

// src/vscode-css-languageservice/parser/postCSSParser.ts
var PostCSSParser = class extends Parser {
  constructor() {
    super(new PostCSSScanner());
  }
  _parseStylesheetStatement(isNested = false) {
    if (this.peek(1 /* AtKeyword */)) {
      return this._parseWarnAndDebug() || this._parseControlStatement() || this._parseMixinDeclaration() || this._parseMixinContent() || this._parseMixinReference() || this._parseFunctionDeclaration() || this._parseForward() || this._parseUse() || this._parseRuleset(isNested) || super._parseStylesheetAtStatement(isNested);
    }
    return this._parseRuleset(true) || this._parseVariableDeclaration();
  }
  _parseImport() {
    if (!this.peekKeyword("@import")) {
      return null;
    }
    const node = this.create(Import);
    this.consumeToken();
    if (!node.addChild(this._parseURILiteral()) && !node.addChild(this._parseStringLiteral())) {
      return this.finish(node, ParseError.URIOrStringExpected);
    }
    while (this.accept(35 /* Comma */)) {
      if (!node.addChild(this._parseURILiteral()) && !node.addChild(this._parseStringLiteral())) {
        return this.finish(node, ParseError.URIOrStringExpected);
      }
    }
    if (!this.peek(13 /* SemiColon */) && !this.peek(41 /* EOF */)) {
      node.setMedialist(this._parseMediaQueryList());
    }
    return this.finish(node);
  }
  _parseVariableDeclaration(panic = []) {
    if (!this.peek(VariableName)) {
      return null;
    }
    const node = this.create(VariableDeclaration);
    if (!node.setVariable(this._parseVariable())) {
      return null;
    }
    if (!this.accept(12 /* Colon */)) {
      return this.finish(node, ParseError.ColonExpected);
    }
    if (this.prevToken) {
      node.colonPosition = this.prevToken.offset;
    }
    if (!node.setValue(this._parseExpr())) {
      return this.finish(node, ParseError.VariableValueExpected, [], panic);
    }
    while (this.peek(33 /* Exclamation */)) {
      if (node.addChild(this._tryParsePrio())) {
      } else {
        this.consumeToken();
        if (!this.peekRegExp(0 /* Ident */, /^(default|global)$/)) {
          return this.finish(node, ParseError.UnknownKeyword);
        }
        this.consumeToken();
      }
    }
    if (this.peek(13 /* SemiColon */)) {
      node.semicolonPosition = this.token.offset;
    }
    return this.finish(node);
  }
  _parseMediaCondition() {
    return this._parseInterpolation() || super._parseMediaCondition();
  }
  _parseMediaFeatureName() {
    return this._parseModuleMember() || this._parseFunction() || this._parseIdent() || this._parseVariable();
  }
  _parseKeyframeSelector() {
    return this._tryParseKeyframeSelector() || this._parseControlStatement(this._parseKeyframeSelector.bind(this)) || this._parseVariableDeclaration() || this._parseMixinContent();
  }
  _parseVariable() {
    if (!this.peek(VariableName)) {
      return null;
    }
    const node = this.create(Variable);
    this.consumeToken();
    return node;
  }
  _parseModuleMember() {
    const pos = this.mark();
    const node = this.create(Module);
    if (!node.setIdentifier(this._parseIdent([6 /* Module */]))) {
      return null;
    }
    if (this.hasWhitespace() || !this.acceptDelim(".") || this.hasWhitespace()) {
      this.restoreAtMark(pos);
      return null;
    }
    if (!node.addChild(this._parseVariable() || this._parseFunction())) {
      return this.finish(node, ParseError.IdentifierOrVariableExpected);
    }
    return node;
  }
  _parseIdent(referenceTypes) {
    if (!this.peek(0 /* Ident */) && !this.peek(InterpolationFunction) && !this.peekDelim("-")) {
      return null;
    }
    const node = this.create(Identifier);
    node.referenceTypes = referenceTypes;
    node.isCustomProperty = this.peekRegExp(0 /* Ident */, /^--/);
    let hasContent = false;
    const indentInterpolation = () => {
      const pos = this.mark();
      if (this.acceptDelim("-")) {
        if (!this.hasWhitespace()) {
          this.acceptDelim("-");
        }
        if (this.hasWhitespace()) {
          this.restoreAtMark(pos);
          return null;
        }
      }
      return this._parseInterpolation();
    };
    while (this.accept(0 /* Ident */) || node.addChild(indentInterpolation()) || hasContent && this.acceptRegexp(/^[\w-]/)) {
      hasContent = true;
      if (this.hasWhitespace()) {
        break;
      }
    }
    return hasContent ? this.finish(node) : null;
  }
  _parseTermExpression() {
    return this._parseModuleMember() || this._parseVariable() || this._parseSelectorCombinator() || super._parseTermExpression();
  }
  _parseInterpolation() {
    if (this.peek(InterpolationFunction)) {
      const node = this.create(Interpolation);
      this.consumeToken();
      if (!node.addChild(this._parseExpr()) && !this._parseSelectorCombinator()) {
        if (this.accept(17 /* ParenthesisR */)) {
          return this.finish(node);
        }
        return this.finish(node, ParseError.ExpressionExpected);
      }
      if (!this.accept(17 /* ParenthesisR */)) {
        return this.finish(node, ParseError.RightParenthesisExpected);
      }
      return this.finish(node);
    }
    return null;
  }
  _parseOperator() {
    if (this.peek(EqualsOperator) || this.peek(NotEqualsOperator) || this.peek(GreaterEqualsOperator) || this.peek(SmallerEqualsOperator) || this.peekDelim(">") || this.peekDelim("<") || this.peekIdent("and") || this.peekIdent("or") || this.peekDelim("%")) {
      const node = this.createNode(25 /* Operator */);
      this.consumeToken();
      return this.finish(node);
    }
    return super._parseOperator();
  }
  _parseUnaryOperator() {
    if (this.peekIdent("not")) {
      const node = this.create(Node);
      this.consumeToken();
      return this.finish(node);
    }
    return super._parseUnaryOperator();
  }
  _parseRuleSetDeclaration() {
    if (this.peek(1 /* AtKeyword */)) {
      return this._parseKeyframe() || this._parseImport() || this._parseMedia(true) || this._parseFontFace() || this._parseWarnAndDebug() || this._parseControlStatement() || this._parseFunctionDeclaration() || this._parseExtends() || this._parseMixinReference() || this._parseMixinContent() || this._parseMixinDeclaration() || this._parseNestedKeyword() || this._parseRuleset(true) || this._parseSupports(true) || this._parseLayer() || super._parseRuleSetDeclarationAtStatement();
    }
    return this._parseVariableDeclaration() || this._tryParseRuleset(true) || super._parseRuleSetDeclaration();
  }
  _parseDeclaration(stopTokens) {
    const custonProperty = this._tryParseCustomPropertyDeclaration(stopTokens);
    if (custonProperty) {
      return custonProperty;
    }
    const node = this.create(Declaration);
    if (!node.setProperty(this._parseProperty())) {
      return null;
    }
    if (!this.accept(12 /* Colon */)) {
      return this.finish(node, ParseError.ColonExpected, [12 /* Colon */], stopTokens || [13 /* SemiColon */]);
    }
    if (this.prevToken) {
      node.colonPosition = this.prevToken.offset;
    }
    let hasContent = false;
    if (node.setValue(this._parseExpr())) {
      hasContent = true;
      node.addChild(this._parsePrio());
    }
    if (this.peek(14 /* CurlyL */)) {
      node.setNestedProperties(this._parseNestedProperties());
    } else {
      if (!hasContent) {
        return this.finish(node, ParseError.PropertyValueExpected);
      }
    }
    if (this.peek(13 /* SemiColon */)) {
      node.semicolonPosition = this.token.offset;
    }
    return this.finish(node);
  }
  _parseNestedProperties() {
    const node = this.create(NestedProperties);
    return this._parseBody(node, this._parseDeclaration.bind(this));
  }
  _parseExtends() {
    if (this.peekKeyword("composes")) {
      const node = this.create(ExtendsReference);
      this.consumeToken();
      if (!node.getSelectors().addChild(this._parseSimpleSelector())) {
        return this.finish(node, ParseError.SelectorExpected);
      }
      while (this.accept(35 /* Comma */)) {
        node.getSelectors().addChild(this._parseSimpleSelector());
      }
      if (this.accept(33 /* Exclamation */)) {
        if (!this.acceptIdent("optional")) {
          return this.finish(node, ParseError.UnknownKeyword);
        }
      }
      return this.finish(node);
    }
    return null;
  }
  _parseSimpleSelectorBody() {
    return this._parseSelectorCombinator() || this._parseSelectorPlaceholder() || super._parseSimpleSelectorBody();
  }
  _parseSelectorCombinator() {
    if (this.peekDelim("&")) {
      const node = this.createNode(7 /* SelectorCombinator */);
      this.consumeToken();
      while (!this.hasWhitespace() && (this.acceptDelim("-") || this.accept(6 /* Num */) || this.accept(8 /* Dimension */) || node.addChild(this._parseIdent()) || this.acceptDelim("&"))) {
      }
      return this.finish(node);
    }
    return null;
  }
  _parseSelectorPlaceholder() {
    if (this.peekDelim("%")) {
      const node = this.createNode(42 /* SelectorPlaceholder */);
      this.consumeToken();
      this._parseIdent();
      return this.finish(node);
    } else if (this.peekKeyword("@at-root")) {
      const node = this.createNode(42 /* SelectorPlaceholder */);
      this.consumeToken();
      return this.finish(node);
    }
    return null;
  }
  _parseElementName() {
    const pos = this.mark();
    const node = super._parseElementName();
    if (node && !this.hasWhitespace() && this.peek(16 /* ParenthesisL */)) {
      this.restoreAtMark(pos);
      return null;
    }
    return node;
  }
  _tryParsePseudoIdentifier() {
    return this._parseInterpolation() || super._tryParsePseudoIdentifier();
  }
  _parseWarnAndDebug() {
    if (!this.peekKeyword("@debug") && !this.peekKeyword("@warn") && !this.peekKeyword("@error")) {
      return null;
    }
    const node = this.createNode(43 /* Debug */);
    this.consumeToken();
    node.addChild(this._parseExpr());
    return this.finish(node);
  }
  _parseControlStatement(parseStatement = this._parseRuleSetDeclaration.bind(this)) {
    if (!this.peek(1 /* AtKeyword */)) {
      return null;
    }
    return this._parseIfStatement(parseStatement) || this._parseForStatement(parseStatement) || this._parseEachStatement(parseStatement) || this._parseWhileStatement(parseStatement);
  }
  _parseIfStatement(parseStatement) {
    if (!this.peekKeyword("@if")) {
      return null;
    }
    return this._internalParseIfStatement(parseStatement);
  }
  _internalParseIfStatement(parseStatement) {
    const node = this.create(IfStatement);
    this.consumeToken();
    if (!node.setExpression(this._parseExpr(true))) {
      return this.finish(node, ParseError.ExpressionExpected);
    }
    this._parseBody(node, parseStatement);
    if (this.acceptKeyword("@else")) {
      if (this.peekIdent("if")) {
        node.setElseClause(this._internalParseIfStatement(parseStatement));
      } else if (this.peek(14 /* CurlyL */)) {
        const elseNode = this.create(ElseStatement);
        this._parseBody(elseNode, parseStatement);
        node.setElseClause(elseNode);
      }
    }
    return this.finish(node);
  }
  _parseForStatement(parseStatement) {
    if (!this.peekKeyword("@for")) {
      return null;
    }
    const node = this.create(ForStatement);
    this.consumeToken();
    if (!node.setVariable(this._parseVariable())) {
      return this.finish(node, ParseError.VariableNameExpected, [15 /* CurlyR */]);
    }
    if (!this.acceptIdent("from")) {
      return this.finish(node, SCSSParseError.FromExpected, [15 /* CurlyR */]);
    }
    if (!node.addChild(this._parseBinaryExpr())) {
      return this.finish(node, ParseError.ExpressionExpected, [15 /* CurlyR */]);
    }
    if (!this.acceptIdent("to") && !this.acceptIdent("through")) {
      return this.finish(node, SCSSParseError.ThroughOrToExpected, [15 /* CurlyR */]);
    }
    if (!node.addChild(this._parseBinaryExpr())) {
      return this.finish(node, ParseError.ExpressionExpected, [15 /* CurlyR */]);
    }
    return this._parseBody(node, parseStatement);
  }
  _parseEachStatement(parseStatement) {
    if (!this.peekKeyword("@each")) {
      return null;
    }
    const node = this.create(EachStatement);
    this.consumeToken();
    const variables = node.getVariables();
    if (!variables.addChild(this._parseVariable())) {
      return this.finish(node, ParseError.VariableNameExpected, [15 /* CurlyR */]);
    }
    while (this.accept(35 /* Comma */)) {
      if (!variables.addChild(this._parseVariable())) {
        return this.finish(node, ParseError.VariableNameExpected, [15 /* CurlyR */]);
      }
    }
    this.finish(variables);
    if (!this.acceptIdent("in")) {
      return this.finish(node, SCSSParseError.InExpected, [15 /* CurlyR */]);
    }
    if (!node.addChild(this._parseExpr())) {
      return this.finish(node, ParseError.ExpressionExpected, [15 /* CurlyR */]);
    }
    return this._parseBody(node, parseStatement);
  }
  _parseWhileStatement(parseStatement) {
    if (!this.peekKeyword("@while")) {
      return null;
    }
    const node = this.create(WhileStatement);
    this.consumeToken();
    if (!node.addChild(this._parseBinaryExpr())) {
      return this.finish(node, ParseError.ExpressionExpected, [15 /* CurlyR */]);
    }
    return this._parseBody(node, parseStatement);
  }
  _parseFunctionBodyDeclaration() {
    return this._parseVariableDeclaration() || this._parseReturnStatement() || this._parseWarnAndDebug() || this._parseControlStatement(this._parseFunctionBodyDeclaration.bind(this));
  }
  _parseFunctionDeclaration() {
    if (!this.peekKeyword("@function")) {
      return null;
    }
    const node = this.create(FunctionDeclaration);
    this.consumeToken();
    if (!node.setIdentifier(this._parseIdent([3 /* Function */]))) {
      return this.finish(node, ParseError.IdentifierExpected, [15 /* CurlyR */]);
    }
    if (!this.accept(16 /* ParenthesisL */)) {
      return this.finish(node, ParseError.LeftParenthesisExpected, [15 /* CurlyR */]);
    }
    if (node.getParameters().addChild(this._parseParameterDeclaration())) {
      while (this.accept(35 /* Comma */)) {
        if (this.peek(17 /* ParenthesisR */)) {
          break;
        }
        if (!node.getParameters().addChild(this._parseParameterDeclaration())) {
          return this.finish(node, ParseError.VariableNameExpected);
        }
      }
    }
    if (!this.accept(17 /* ParenthesisR */)) {
      return this.finish(node, ParseError.RightParenthesisExpected, [15 /* CurlyR */]);
    }
    return this._parseBody(node, this._parseFunctionBodyDeclaration.bind(this));
  }
  _parseReturnStatement() {
    if (!this.peekKeyword("@return")) {
      return null;
    }
    const node = this.createNode(58 /* ReturnStatement */);
    this.consumeToken();
    if (!node.addChild(this._parseExpr())) {
      return this.finish(node, ParseError.ExpressionExpected);
    }
    return this.finish(node);
  }
  _parseMixinDeclaration() {
    if (!this.peekKeyword("@define-mixin")) {
      return null;
    }
    const node = this.create(MixinDeclaration);
    this.consumeToken();
    if (!node.setIdentifier(this._parseIdent([0 /* Mixin */]))) {
      return this.finish(node, ParseError.IdentifierExpected, [15 /* CurlyR */]);
    }
    if (node.getParameters().addChild(this._parseParameterDeclaration())) {
      while (this.accept(35 /* Comma */)) {
        if (!node.getParameters().addChild(this._parseParameterDeclaration())) {
          return this.finish(node, ParseError.VariableNameExpected);
        }
      }
    }
    return this._parseBody(node, this._parseRuleSetDeclaration.bind(this));
  }
  _parseNestedKeyword() {
    if (!this.peekKeyword("@nest")) {
      return null;
    }
    const node = this.create(MixinDeclaration);
    this.consumeToken();
    if (!node.setIdentifier(this._parseIdent([0 /* Mixin */]))) {
      return this.finish(node, ParseError.IdentifierExpected, [15 /* CurlyR */]);
    }
    if (this.accept(16 /* ParenthesisL */)) {
      if (node.getParameters().addChild(this._parseParameterDeclaration())) {
        while (this.accept(35 /* Comma */)) {
          if (this.peek(17 /* ParenthesisR */)) {
            break;
          }
          if (!node.getParameters().addChild(this._parseParameterDeclaration())) {
            return this.finish(node, ParseError.VariableNameExpected);
          }
        }
      }
      if (!this.accept(17 /* ParenthesisR */)) {
        return this.finish(node, ParseError.RightParenthesisExpected, [15 /* CurlyR */]);
      }
    }
    return this._parseBody(node, this._parseRuleSetDeclaration.bind(this));
  }
  _parseParameterDeclaration() {
    const node = this.create(FunctionParameter);
    if (!node.setIdentifier(this._parseVariable())) {
      return null;
    }
    if (this.accept(Ellipsis)) {
    }
    if (this.accept(12 /* Colon */)) {
      if (!node.setDefaultValue(this._parseExpr(true))) {
        return this.finish(node, ParseError.VariableValueExpected, [], [35 /* Comma */, 17 /* ParenthesisR */]);
      }
    }
    return this.finish(node);
  }
  _parseMixinContent() {
    if (!this.peekKeyword("@mixin-content")) {
      return null;
    }
    const node = this.create(MixinContentReference);
    this.consumeToken();
    if (this.accept(16 /* ParenthesisL */)) {
      if (node.getArguments().addChild(this._parseFunctionArgument())) {
        while (this.accept(35 /* Comma */)) {
          if (this.peek(17 /* ParenthesisR */)) {
            break;
          }
          if (!node.getArguments().addChild(this._parseFunctionArgument())) {
            return this.finish(node, ParseError.ExpressionExpected);
          }
        }
      }
      if (!this.accept(17 /* ParenthesisR */)) {
        return this.finish(node, ParseError.RightParenthesisExpected);
      }
    }
    return this.finish(node);
  }
  _parseMixinReference() {
    if (!this.peekKeyword("@mixin")) {
      return null;
    }
    const node = this.create(MixinReference);
    this.consumeToken();
    const firstIdent = this._parseIdent([0 /* Mixin */]);
    if (!node.setIdentifier(firstIdent)) {
      return this.finish(node, ParseError.IdentifierExpected, [15 /* CurlyR */]);
    }
    if (!this.hasWhitespace() && this.acceptDelim(".") && !this.hasWhitespace()) {
      const secondIdent = this._parseIdent([0 /* Mixin */]);
      if (!secondIdent) {
        return this.finish(node, ParseError.IdentifierExpected, [15 /* CurlyR */]);
      }
      const moduleToken = this.create(Module);
      firstIdent.referenceTypes = [6 /* Module */];
      moduleToken.setIdentifier(firstIdent);
      node.setIdentifier(secondIdent);
      node.addChild(moduleToken);
    }
    if (node.getArguments().addChild(this._parseFunctionArgument())) {
      while (this.accept(35 /* Comma */)) {
        if (!node.getArguments().addChild(this._parseFunctionArgument())) {
          return this.finish(node, ParseError.ExpressionExpected);
        }
      }
    }
    if (this.peekIdent("using") || this.peek(14 /* CurlyL */)) {
      node.setContent(this._parseMixinContentDeclaration());
    }
    return this.finish(node);
  }
  _parseMixinContentDeclaration() {
    const node = this.create(MixinContentDeclaration);
    if (this.acceptIdent("using")) {
      if (!this.accept(16 /* ParenthesisL */)) {
        return this.finish(node, ParseError.LeftParenthesisExpected, [14 /* CurlyL */]);
      }
      if (node.getParameters().addChild(this._parseParameterDeclaration())) {
        while (this.accept(35 /* Comma */)) {
          if (this.peek(17 /* ParenthesisR */)) {
            break;
          }
          if (!node.getParameters().addChild(this._parseParameterDeclaration())) {
            return this.finish(node, ParseError.VariableNameExpected);
          }
        }
      }
      if (!this.accept(17 /* ParenthesisR */)) {
        return this.finish(node, ParseError.RightParenthesisExpected, [14 /* CurlyL */]);
      }
    }
    if (this.peek(14 /* CurlyL */)) {
      this._parseBody(node, this._parseMixinReferenceBodyStatement.bind(this));
    }
    return this.finish(node);
  }
  _parseMixinReferenceBodyStatement() {
    return this._tryParseKeyframeSelector() || this._parseRuleSetDeclaration();
  }
  _parseFunctionArgument() {
    const node = this.create(FunctionArgument);
    const pos = this.mark();
    const argument = this._parseVariable();
    if (argument) {
      if (!this.accept(12 /* Colon */)) {
        if (this.accept(Ellipsis)) {
          node.setValue(argument);
          return this.finish(node);
        } else {
          this.restoreAtMark(pos);
        }
      } else {
        node.setIdentifier(argument);
      }
    }
    if (node.setValue(this._parseExpr(true))) {
      this.accept(Ellipsis);
      node.addChild(this._parsePrio());
      return this.finish(node);
    } else if (node.setValue(this._tryParsePrio())) {
      return this.finish(node);
    }
    return null;
  }
  _parseURLArgument() {
    const pos = this.mark();
    const node = super._parseURLArgument();
    if (!node || !this.peek(17 /* ParenthesisR */)) {
      this.restoreAtMark(pos);
      const node2 = this.create(Node);
      node2.addChild(this._parseBinaryExpr());
      return this.finish(node2);
    }
    return node;
  }
  _parseOperation() {
    if (!this.peek(16 /* ParenthesisL */)) {
      return null;
    }
    const node = this.create(Node);
    this.consumeToken();
    while (node.addChild(this._parseListElement())) {
      this.accept(35 /* Comma */);
    }
    if (!this.accept(17 /* ParenthesisR */)) {
      return this.finish(node, ParseError.RightParenthesisExpected);
    }
    return this.finish(node);
  }
  _parseListElement() {
    const node = this.create(ListEntry);
    const child = this._parseBinaryExpr();
    if (!child) {
      return null;
    }
    if (this.accept(12 /* Colon */)) {
      node.setKey(child);
      if (!node.setValue(this._parseBinaryExpr())) {
        return this.finish(node, ParseError.ExpressionExpected);
      }
    } else {
      node.setValue(child);
    }
    return this.finish(node);
  }
  _parseUse() {
    if (!this.peekKeyword("@use")) {
      return null;
    }
    const node = this.create(Use);
    this.consumeToken();
    if (!node.addChild(this._parseStringLiteral())) {
      return this.finish(node, ParseError.StringLiteralExpected);
    }
    if (!this.peek(13 /* SemiColon */) && !this.peek(41 /* EOF */)) {
      if (!this.peekRegExp(0 /* Ident */, /as|with/)) {
        return this.finish(node, ParseError.UnknownKeyword);
      }
      if (this.acceptIdent("as") && (!node.setIdentifier(this._parseIdent([6 /* Module */])) && !this.acceptDelim("*"))) {
        return this.finish(node, ParseError.IdentifierOrWildcardExpected);
      }
      if (this.acceptIdent("with")) {
        if (!this.accept(16 /* ParenthesisL */)) {
          return this.finish(node, ParseError.LeftParenthesisExpected, [17 /* ParenthesisR */]);
        }
        if (!node.getParameters().addChild(this._parseModuleConfigDeclaration())) {
          return this.finish(node, ParseError.VariableNameExpected);
        }
        while (this.accept(35 /* Comma */)) {
          if (this.peek(17 /* ParenthesisR */)) {
            break;
          }
          if (!node.getParameters().addChild(this._parseModuleConfigDeclaration())) {
            return this.finish(node, ParseError.VariableNameExpected);
          }
        }
        if (!this.accept(17 /* ParenthesisR */)) {
          return this.finish(node, ParseError.RightParenthesisExpected);
        }
      }
    }
    if (!this.accept(13 /* SemiColon */) && !this.accept(41 /* EOF */)) {
      return this.finish(node, ParseError.SemiColonExpected);
    }
    return this.finish(node);
  }
  _parseModuleConfigDeclaration() {
    const node = this.create(ModuleConfiguration);
    if (!node.setIdentifier(this._parseVariable())) {
      return null;
    }
    if (!this.accept(12 /* Colon */) || !node.setValue(this._parseExpr(true))) {
      return this.finish(node, ParseError.VariableValueExpected, [], [35 /* Comma */, 17 /* ParenthesisR */]);
    }
    if (this.accept(33 /* Exclamation */)) {
      if (this.hasWhitespace() || !this.acceptIdent("default")) {
        return this.finish(node, ParseError.UnknownKeyword);
      }
    }
    return this.finish(node);
  }
  _parseForward() {
    if (!this.peekKeyword("@forward")) {
      return null;
    }
    const node = this.create(Forward);
    this.consumeToken();
    if (!node.addChild(this._parseStringLiteral())) {
      return this.finish(node, ParseError.StringLiteralExpected);
    }
    if (this.acceptIdent("with")) {
      if (!this.accept(16 /* ParenthesisL */)) {
        return this.finish(node, ParseError.LeftParenthesisExpected, [17 /* ParenthesisR */]);
      }
      if (!node.getParameters().addChild(this._parseModuleConfigDeclaration())) {
        return this.finish(node, ParseError.VariableNameExpected);
      }
      while (this.accept(35 /* Comma */)) {
        if (this.peek(17 /* ParenthesisR */)) {
          break;
        }
        if (!node.getParameters().addChild(this._parseModuleConfigDeclaration())) {
          return this.finish(node, ParseError.VariableNameExpected);
        }
      }
      if (!this.accept(17 /* ParenthesisR */)) {
        return this.finish(node, ParseError.RightParenthesisExpected);
      }
    }
    if (!this.peek(13 /* SemiColon */) && !this.peek(41 /* EOF */)) {
      if (!this.peekRegExp(0 /* Ident */, /as|hide|show/)) {
        return this.finish(node, ParseError.UnknownKeyword);
      }
      if (this.acceptIdent("as")) {
        const identifier = this._parseIdent([7 /* Forward */]);
        if (!node.setIdentifier(identifier)) {
          return this.finish(node, ParseError.IdentifierExpected);
        }
        if (this.hasWhitespace() || !this.acceptDelim("*")) {
          return this.finish(node, ParseError.WildcardExpected);
        }
      }
      if (this.peekIdent("hide") || this.peekIdent("show")) {
        if (!node.addChild(this._parseForwardVisibility())) {
          return this.finish(node, ParseError.IdentifierOrVariableExpected);
        }
      }
    }
    if (!this.accept(13 /* SemiColon */) && !this.accept(41 /* EOF */)) {
      return this.finish(node, ParseError.SemiColonExpected);
    }
    return this.finish(node);
  }
  _parseForwardVisibility() {
    const node = this.create(ForwardVisibility);
    node.setIdentifier(this._parseIdent());
    while (node.addChild(this._parseVariable() || this._parseIdent())) {
      this.accept(35 /* Comma */);
    }
    return node.getChildren().length > 1 ? node : null;
  }
  _parseSupportsCondition() {
    return this._parseInterpolation() || super._parseSupportsCondition();
  }
};

// src/vscode-css-languageservice/parser/cssSymbolScope.ts
var Scope = class {
  constructor(offset, length) {
    this.offset = offset;
    this.length = length;
    this.symbols = [];
    this.parent = null;
    this.children = [];
  }
  addChild(scope) {
    this.children.push(scope);
    scope.setParent(this);
  }
  setParent(scope) {
    this.parent = scope;
  }
  findScope(offset, length = 0) {
    if (this.offset <= offset && this.offset + this.length > offset + length || this.offset === offset && this.length === length) {
      return this.findInScope(offset, length);
    }
    return null;
  }
  findInScope(offset, length = 0) {
    const end = offset + length;
    const idx = findFirst(this.children, (s) => s.offset > end);
    if (idx === 0) {
      return this;
    }
    const res = this.children[idx - 1];
    if (res.offset <= offset && res.offset + res.length >= offset + length) {
      return res.findInScope(offset, length);
    }
    return this;
  }
  addSymbol(symbol) {
    this.symbols.push(symbol);
  }
  getSymbol(name, type) {
    for (let index = 0; index < this.symbols.length; index++) {
      const symbol = this.symbols[index];
      if (symbol.name === name && symbol.type === type) {
        return symbol;
      }
    }
    return null;
  }
  getSymbols() {
    return this.symbols;
  }
};
var GlobalScope = class extends Scope {
  constructor() {
    super(0, Number.MAX_VALUE);
  }
};
var Symbol = class {
  constructor(name, value, node, type) {
    this.name = name;
    this.value = value;
    this.node = node;
    this.type = type;
  }
};
var ScopeBuilder = class {
  constructor(scope) {
    this.scope = scope;
  }
  addSymbol(node, name, value, type) {
    if (node.offset !== -1) {
      const current = this.scope.findScope(node.offset, node.length);
      if (current) {
        current.addSymbol(new Symbol(name, value, node, type));
      }
    }
  }
  addScope(node) {
    if (node.offset !== -1) {
      const current = this.scope.findScope(node.offset, node.length);
      if (current && (current.offset !== node.offset || current.length !== node.length)) {
        const newScope = new Scope(node.offset, node.length);
        current.addChild(newScope);
        return newScope;
      }
      return current;
    }
    return null;
  }
  addSymbolToChildScope(scopeNode, node, name, value, type) {
    if (scopeNode && scopeNode.offset !== -1) {
      const current = this.addScope(scopeNode);
      if (current) {
        current.addSymbol(new Symbol(name, value, node, type));
      }
    }
  }
  visitNode(node) {
    switch (node.type) {
      case 52 /* Keyframe */:
        this.addSymbol(node, node.getName(), void 0, 4 /* Keyframe */);
        return true;
      case 68 /* CustomPropertyDeclaration */:
        return this.visitCustomPropertyDeclarationNode(node);
      case 37 /* VariableDeclaration */:
        return this.visitVariableDeclarationNode(node);
      case 3 /* Ruleset */:
        return this.visitRuleSet(node);
      case 34 /* MixinDeclaration */:
        this.addSymbol(node, node.getName(), void 0, 0 /* Mixin */);
        return true;
      case 57 /* FunctionDeclaration */:
        this.addSymbol(node, node.getName(), void 0, 3 /* Function */);
        return true;
      case 62 /* FunctionParameter */: {
        return this.visitFunctionParameterNode(node);
      }
      case 20 /* Declarations */:
        this.addScope(node);
        return true;
      case 46 /* For */:
        const forNode = node;
        const scopeNode = forNode.getDeclarations();
        if (scopeNode && forNode.variable) {
          this.addSymbolToChildScope(scopeNode, forNode.variable, forNode.variable.getName(), void 0, 2 /* Variable */);
        }
        return true;
      case 47 /* Each */: {
        const eachNode = node;
        const scopeNode2 = eachNode.getDeclarations();
        if (scopeNode2) {
          const variables = eachNode.getVariables().getChildren();
          for (const variable of variables) {
            this.addSymbolToChildScope(scopeNode2, variable, variable.getName(), void 0, 2 /* Variable */);
          }
        }
        return true;
      }
    }
    return true;
  }
  visitRuleSet(node) {
    const current = this.scope.findScope(node.offset, node.length);
    if (current) {
      for (const child of node.getSelectors().getChildren()) {
        if (child instanceof Selector) {
          if (child.getChildren().length === 1) {
            current.addSymbol(new Symbol(child.getChild(0).getText(), void 0, child, 1 /* Rule */));
          }
        }
      }
    }
    return true;
  }
  visitVariableDeclarationNode(node) {
    const value = node.getValue() ? node.getValue().getText() : void 0;
    this.addSymbol(node, node.getName(), value, 2 /* Variable */);
    return true;
  }
  visitFunctionParameterNode(node) {
    const scopeNode = node.getParent().getDeclarations();
    if (scopeNode) {
      const valueNode = node.getDefaultValue();
      const value = valueNode ? valueNode.getText() : void 0;
      this.addSymbolToChildScope(scopeNode, node, node.getName(), value, 2 /* Variable */);
    }
    return true;
  }
  visitCustomPropertyDeclarationNode(node) {
    const value = node.getValue() ? node.getValue().getText() : "";
    this.addCSSVariable(node.getProperty(), node.getProperty().getName(), value, 2 /* Variable */);
    return true;
  }
  addCSSVariable(node, name, value, type) {
    if (node.offset !== -1) {
      this.scope.addSymbol(new Symbol(name, value, node, type));
    }
  }
};
var Symbols = class {
  constructor(node) {
    this.global = new GlobalScope();
    node.acceptVisitor(new ScopeBuilder(this.global));
  }
  findSymbolsAtOffset(offset, referenceType) {
    let scope = this.global.findScope(offset, 0);
    const result = [];
    const names = {};
    while (scope) {
      const symbols = scope.getSymbols();
      for (let i = 0; i < symbols.length; i++) {
        const symbol = symbols[i];
        if (symbol.type === referenceType && !names[symbol.name]) {
          result.push(symbol);
          names[symbol.name] = true;
        }
      }
      scope = scope.parent;
    }
    return result;
  }
  internalFindSymbol(node, referenceTypes) {
    let scopeNode = node;
    if (node.parent instanceof FunctionParameter && node.parent.getParent() instanceof BodyDeclaration) {
      scopeNode = node.parent.getParent().getDeclarations();
    }
    if (node.parent instanceof FunctionArgument && node.parent.getParent() instanceof Function) {
      const funcId = node.parent.getParent().getIdentifier();
      if (funcId) {
        const functionSymbol = this.internalFindSymbol(funcId, [3 /* Function */]);
        if (functionSymbol) {
          scopeNode = functionSymbol.node.getDeclarations();
        }
      }
    }
    if (!scopeNode) {
      return null;
    }
    const name = node.getText();
    let scope = this.global.findScope(scopeNode.offset, scopeNode.length);
    while (scope) {
      for (let index = 0; index < referenceTypes.length; index++) {
        const type = referenceTypes[index];
        const symbol = scope.getSymbol(name, type);
        if (symbol) {
          return symbol;
        }
      }
      scope = scope.parent;
    }
    return null;
  }
  evaluateReferenceTypes(node) {
    if (node instanceof Identifier) {
      const referenceTypes = node.referenceTypes;
      if (referenceTypes) {
        return referenceTypes;
      } else {
        if (node.isCustomProperty) {
          return [2 /* Variable */];
        }
        const decl = getParentDeclaration(node);
        if (decl) {
          const propertyName = decl.getNonPrefixedPropertyName();
          if ((propertyName === "animation" || propertyName === "animation-name") && decl.getValue() && decl.getValue().offset === node.offset) {
            return [4 /* Keyframe */];
          }
        }
      }
    } else if (node instanceof Variable) {
      return [2 /* Variable */];
    }
    const selector = node.findAParent(4 /* Selector */, 41 /* ExtendsReference */);
    if (selector) {
      return [1 /* Rule */];
    }
    return null;
  }
  findSymbolFromNode(node) {
    if (!node) {
      return null;
    }
    while (node.type === 39 /* Interpolation */) {
      node = node.getParent();
    }
    const referenceTypes = this.evaluateReferenceTypes(node);
    if (referenceTypes) {
      return this.internalFindSymbol(node, referenceTypes);
    }
    return null;
  }
  matchesSymbol(node, symbol) {
    if (!node) {
      return false;
    }
    while (node.type === 39 /* Interpolation */) {
      node = node.getParent();
    }
    if (!node.matches(symbol.name)) {
      return false;
    }
    const referenceTypes = this.evaluateReferenceTypes(node);
    if (!referenceTypes || referenceTypes.indexOf(symbol.type) === -1) {
      return false;
    }
    const nodeSymbol = this.internalFindSymbol(node, referenceTypes);
    return nodeSymbol === symbol;
  }
  findSymbol(name, type, offset) {
    let scope = this.global.findScope(offset);
    while (scope) {
      const symbol = scope.getSymbol(name, type);
      if (symbol) {
        return symbol;
      }
      scope = scope.parent;
    }
    return null;
  }
};

// src/vscode-css-languageservice/services/cssCompletion.ts
import * as nls8 from "vscode-nls";

// src/vscode-css-languageservice/utils/resources.ts
import { URI, Utils } from "vscode-uri";
function dirname(uriString) {
  return Utils.dirname(URI.parse(uriString)).toString(true);
}
function joinPath(uriString, ...paths) {
  return Utils.joinPath(URI.parse(uriString), ...paths).toString(true);
}

// src/vscode-css-languageservice/services/pathCompletion.ts
var PathCompletionParticipant = class {
  constructor(readDirectory) {
    this.readDirectory = readDirectory;
    this.literalCompletions = [];
    this.importCompletions = [];
  }
  onCssURILiteralValue(context) {
    this.literalCompletions.push(context);
  }
  onCssImportPath(context) {
    this.importCompletions.push(context);
  }
  async computeCompletions(document, documentContext) {
    const result = { items: [], isIncomplete: false };
    for (const literalCompletion of this.literalCompletions) {
      const uriValue = literalCompletion.uriValue;
      const fullValue = stripQuotes(uriValue);
      if (fullValue === "." || fullValue === "..") {
        result.isIncomplete = true;
      } else {
        const items = await this.providePathSuggestions(uriValue, literalCompletion.position, literalCompletion.range, document, documentContext);
        for (const item of items) {
          result.items.push(item);
        }
      }
    }
    for (const importCompletion of this.importCompletions) {
      const pathValue = importCompletion.pathValue;
      const fullValue = stripQuotes(pathValue);
      if (fullValue === "." || fullValue === "..") {
        result.isIncomplete = true;
      } else {
        const suggestions = await this.providePathSuggestions(pathValue, importCompletion.position, importCompletion.range, document, documentContext);
        if (document.languageId === "scss") {
          suggestions.forEach((s) => {
            if (startsWith(s.label, "_") && endsWith(s.label, ".scss")) {
              if (s.textEdit) {
                s.textEdit.newText = s.label.slice(1, -5);
              } else {
                s.label = s.label.slice(1, -5);
              }
            }
          });
        }
        for (const item of suggestions) {
          result.items.push(item);
        }
      }
    }
    return result;
  }
  async providePathSuggestions(pathValue, position, range, document, documentContext) {
    const fullValue = stripQuotes(pathValue);
    const isValueQuoted = startsWith(pathValue, `'`) || startsWith(pathValue, `"`);
    const valueBeforeCursor = isValueQuoted ? fullValue.slice(0, position.character - (range.start.character + 1)) : fullValue.slice(0, position.character - range.start.character);
    const currentDocUri = document.uri;
    const fullValueRange = isValueQuoted ? shiftRange(range, 1, -1) : range;
    const replaceRange = pathToReplaceRange(valueBeforeCursor, fullValue, fullValueRange);
    const valueBeforeLastSlash = valueBeforeCursor.substring(0, valueBeforeCursor.lastIndexOf("/") + 1);
    const parentDir = documentContext.resolveReference(valueBeforeLastSlash || ".", currentDocUri);
    if (parentDir) {
      try {
        const result = [];
        const infos = await this.readDirectory(parentDir);
        for (const [name, type] of infos) {
          if (name.charCodeAt(0) !== CharCode_dot && (type === 2 /* Directory */ || joinPath(parentDir, name) !== currentDocUri)) {
            result.push(createCompletionItem(name, type === 2 /* Directory */, replaceRange));
          }
        }
        return result;
      } catch (e) {
      }
    }
    return [];
  }
};
var CharCode_dot = ".".charCodeAt(0);
function stripQuotes(fullValue) {
  if (startsWith(fullValue, `'`) || startsWith(fullValue, `"`)) {
    return fullValue.slice(1, -1);
  } else {
    return fullValue;
  }
}
function pathToReplaceRange(valueBeforeCursor, fullValue, fullValueRange) {
  let replaceRange;
  const lastIndexOfSlash = valueBeforeCursor.lastIndexOf("/");
  if (lastIndexOfSlash === -1) {
    replaceRange = fullValueRange;
  } else {
    const valueAfterLastSlash = fullValue.slice(lastIndexOfSlash + 1);
    const startPos = shiftPosition(fullValueRange.end, -valueAfterLastSlash.length);
    const whitespaceIndex = valueAfterLastSlash.indexOf(" ");
    let endPos;
    if (whitespaceIndex !== -1) {
      endPos = shiftPosition(startPos, whitespaceIndex);
    } else {
      endPos = fullValueRange.end;
    }
    replaceRange = Range.create(startPos, endPos);
  }
  return replaceRange;
}
function createCompletionItem(name, isDir, replaceRange) {
  if (isDir) {
    name = name + "/";
    return {
      label: escapePath(name),
      kind: CompletionItemKind.Folder,
      textEdit: TextEdit.replace(replaceRange, escapePath(name)),
      command: {
        title: "Suggest",
        command: "editor.action.triggerSuggest"
      }
    };
  } else {
    return {
      label: escapePath(name),
      kind: CompletionItemKind.File,
      textEdit: TextEdit.replace(replaceRange, escapePath(name))
    };
  }
}
function escapePath(p) {
  return p.replace(/(\s|\(|\)|,|"|')/g, "\\$1");
}
function shiftPosition(pos, offset) {
  return Position.create(pos.line, pos.character + offset);
}
function shiftRange(range, startOffset, endOffset) {
  const start = shiftPosition(range.start, startOffset);
  const end = shiftPosition(range.end, endOffset);
  return Range.create(start, end);
}

// src/vscode-css-languageservice/services/cssCompletion.ts
var localize8 = nls8.loadMessageBundle();
var SnippetFormat = InsertTextFormat.Snippet;
var retriggerCommand = {
  title: "Suggest",
  command: "editor.action.triggerSuggest"
};
var CSSCompletion = class {
  constructor(variablePrefix = null, lsOptions, cssDataManager) {
    this.variablePrefix = variablePrefix;
    this.lsOptions = lsOptions;
    this.cssDataManager = cssDataManager;
    this.completionParticipants = [];
  }
  configure(settings) {
    this.defaultSettings = settings;
  }
  getSymbolContext() {
    if (!this.symbolContext) {
      this.symbolContext = new Symbols(this.styleSheet);
    }
    return this.symbolContext;
  }
  setCompletionParticipants(registeredCompletionParticipants) {
    this.completionParticipants = registeredCompletionParticipants || [];
  }
  async doComplete2(document, position, styleSheet, documentContext, completionSettings = this.defaultSettings) {
    if (!this.lsOptions.fileSystemProvider || !this.lsOptions.fileSystemProvider.readDirectory) {
      return this.doComplete(document, position, styleSheet, completionSettings);
    }
    const participant = new PathCompletionParticipant(this.lsOptions.fileSystemProvider.readDirectory);
    const contributedParticipants = this.completionParticipants;
    this.completionParticipants = [participant].concat(contributedParticipants);
    const result = this.doComplete(document, position, styleSheet, completionSettings);
    try {
      const pathCompletionResult = await participant.computeCompletions(document, documentContext);
      return {
        isIncomplete: result.isIncomplete || pathCompletionResult.isIncomplete,
        items: pathCompletionResult.items.concat(result.items)
      };
    } finally {
      this.completionParticipants = contributedParticipants;
    }
  }
  doComplete(document, position, styleSheet, documentSettings2) {
    this.offset = document.offsetAt(position);
    this.position = position;
    this.currentWord = getCurrentWord(document, this.offset);
    this.defaultReplaceRange = Range.create(Position.create(this.position.line, this.position.character - this.currentWord.length), this.position);
    this.textDocument = document;
    this.styleSheet = styleSheet;
    this.documentSettings = documentSettings2;
    try {
      const result = { isIncomplete: false, items: [] };
      this.nodePath = getNodePath(this.styleSheet, this.offset);
      for (let i = this.nodePath.length - 1; i >= 0; i--) {
        const node = this.nodePath[i];
        if (node instanceof Property) {
          this.getCompletionsForDeclarationProperty(node.getParent(), result);
        } else if (node instanceof Expression) {
          if (node.parent instanceof Interpolation) {
            this.getVariableProposals(null, result);
          } else {
            this.getCompletionsForExpression(node, result);
          }
        } else if (node instanceof SimpleSelector) {
          const parentRef = node.findAParent(41 /* ExtendsReference */, 3 /* Ruleset */);
          if (parentRef) {
            if (parentRef.type === 41 /* ExtendsReference */) {
              this.getCompletionsForExtendsReference(parentRef, node, result);
            } else {
              const parentRuleSet = parentRef;
              this.getCompletionsForSelector(parentRuleSet, parentRuleSet && parentRuleSet.isNested(), result);
            }
          }
        } else if (node instanceof FunctionArgument) {
          this.getCompletionsForFunctionArgument(node, node.getParent(), result);
        } else if (node instanceof Declarations) {
          this.getCompletionsForDeclarations(node, result);
        } else if (node instanceof VariableDeclaration) {
          this.getCompletionsForVariableDeclaration(node, result);
        } else if (node instanceof RuleSet) {
          this.getCompletionsForRuleSet(node, result);
        } else if (node instanceof Interpolation) {
          this.getCompletionsForInterpolation(node, result);
        } else if (node instanceof FunctionDeclaration) {
          this.getCompletionsForFunctionDeclaration(node, result);
        } else if (node instanceof MixinReference) {
          this.getCompletionsForMixinReference(node, result);
        } else if (node instanceof Function) {
          this.getCompletionsForFunctionArgument(null, node, result);
        } else if (node instanceof Supports) {
          this.getCompletionsForSupports(node, result);
        } else if (node instanceof SupportsCondition) {
          this.getCompletionsForSupportsCondition(node, result);
        } else if (node instanceof ExtendsReference) {
          this.getCompletionsForExtendsReference(node, null, result);
        } else if (node.type === 28 /* URILiteral */) {
          this.getCompletionForUriLiteralValue(node, result);
        } else if (node.parent === null) {
          this.getCompletionForTopLevel(result);
        } else if (node.type === 27 /* StringLiteral */ && this.isImportPathParent(node.parent.type)) {
          this.getCompletionForImportPath(node, result);
        } else {
          continue;
        }
        if (result.items.length > 0 || this.offset > node.offset) {
          return this.finalize(result);
        }
      }
      this.getCompletionsForStylesheet(result);
      if (result.items.length === 0) {
        if (this.variablePrefix && this.currentWord.indexOf(this.variablePrefix) === 0) {
          this.getVariableProposals(null, result);
        }
      }
      return this.finalize(result);
    } finally {
      this.position = null;
      this.currentWord = null;
      this.textDocument = null;
      this.styleSheet = null;
      this.symbolContext = null;
      this.defaultReplaceRange = null;
      this.nodePath = null;
    }
  }
  isImportPathParent(type) {
    return type === 54 /* Import */;
  }
  finalize(result) {
    return result;
  }
  findInNodePath(...types) {
    for (let i = this.nodePath.length - 1; i >= 0; i--) {
      const node = this.nodePath[i];
      if (types.indexOf(node.type) !== -1) {
        return node;
      }
    }
    return null;
  }
  getCompletionsForDeclarationProperty(declaration, result) {
    return this.getPropertyProposals(declaration, result);
  }
  getPropertyProposals(declaration, result) {
    const triggerPropertyValueCompletion = this.isTriggerPropertyValueCompletionEnabled;
    const completePropertyWithSemicolon = this.isCompletePropertyWithSemicolonEnabled;
    const properties = this.cssDataManager.getProperties();
    properties.forEach((entry) => {
      let range;
      let insertText;
      let retrigger = false;
      if (declaration) {
        range = this.getCompletionRange(declaration.getProperty());
        insertText = entry.name;
        if (!isDefined(declaration.colonPosition)) {
          insertText += ": ";
          retrigger = true;
        }
      } else {
        range = this.getCompletionRange(null);
        insertText = entry.name + ": ";
        retrigger = true;
      }
      if (!declaration && completePropertyWithSemicolon) {
        insertText += "$0;";
      }
      if (declaration && !declaration.semicolonPosition) {
        if (completePropertyWithSemicolon && this.offset >= this.textDocument.offsetAt(range.end)) {
          insertText += "$0;";
        }
      }
      const item = {
        label: entry.name,
        documentation: getEntryDescription(entry, this.doesSupportMarkdown()),
        tags: isDeprecated(entry) ? [CompletionItemTag.Deprecated] : [],
        textEdit: TextEdit.replace(range, insertText),
        insertTextFormat: InsertTextFormat.Snippet,
        kind: CompletionItemKind.Property
      };
      if (!entry.restrictions) {
        retrigger = false;
      }
      if (triggerPropertyValueCompletion && retrigger) {
        item.command = retriggerCommand;
      }
      const relevance = typeof entry.relevance === "number" ? Math.min(Math.max(entry.relevance, 0), 99) : 50;
      const sortTextSuffix = (255 - relevance).toString(16);
      const sortTextPrefix = startsWith(entry.name, "-") ? "x" /* VendorPrefixed */ : "d" /* Normal */;
      item.sortText = sortTextPrefix + "_" + sortTextSuffix;
      result.items.push(item);
    });
    this.completionParticipants.forEach((participant) => {
      if (participant.onCssProperty) {
        participant.onCssProperty({
          propertyName: this.currentWord,
          range: this.defaultReplaceRange
        });
      }
    });
    return result;
  }
  get isTriggerPropertyValueCompletionEnabled() {
    var _a2;
    return ((_a2 = this.documentSettings) == null ? void 0 : _a2.triggerPropertyValueCompletion) ?? true;
  }
  get isCompletePropertyWithSemicolonEnabled() {
    var _a2;
    return ((_a2 = this.documentSettings) == null ? void 0 : _a2.completePropertyWithSemicolon) ?? true;
  }
  getCompletionsForDeclarationValue(node, result) {
    const propertyName = node.getFullPropertyName();
    const entry = this.cssDataManager.getProperty(propertyName);
    let existingNode = node.getValue() || null;
    while (existingNode && existingNode.hasChildren()) {
      existingNode = existingNode.findChildAtOffset(this.offset, false);
    }
    this.completionParticipants.forEach((participant) => {
      if (participant.onCssPropertyValue) {
        participant.onCssPropertyValue({
          propertyName,
          propertyValue: this.currentWord,
          range: this.getCompletionRange(existingNode)
        });
      }
    });
    if (entry) {
      if (entry.restrictions) {
        for (const restriction of entry.restrictions) {
          switch (restriction) {
            case "color":
              this.getColorProposals(entry, existingNode, result);
              break;
            case "position":
              this.getPositionProposals(entry, existingNode, result);
              break;
            case "repeat":
              this.getRepeatStyleProposals(entry, existingNode, result);
              break;
            case "line-style":
              this.getLineStyleProposals(entry, existingNode, result);
              break;
            case "line-width":
              this.getLineWidthProposals(entry, existingNode, result);
              break;
            case "geometry-box":
              this.getGeometryBoxProposals(entry, existingNode, result);
              break;
            case "box":
              this.getBoxProposals(entry, existingNode, result);
              break;
            case "image":
              this.getImageProposals(entry, existingNode, result);
              break;
            case "timing-function":
              this.getTimingFunctionProposals(entry, existingNode, result);
              break;
            case "shape":
              this.getBasicShapeProposals(entry, existingNode, result);
              break;
          }
        }
      }
      this.getValueEnumProposals(entry, existingNode, result);
      this.getCSSWideKeywordProposals(entry, existingNode, result);
      this.getUnitProposals(entry, existingNode, result);
    } else {
      const existingValues = collectValues(this.styleSheet, node);
      for (const existingValue of existingValues.getEntries()) {
        result.items.push({
          label: existingValue,
          textEdit: TextEdit.replace(this.getCompletionRange(existingNode), existingValue),
          kind: CompletionItemKind.Value
        });
      }
    }
    this.getVariableProposals(existingNode, result);
    this.getTermProposals(entry, existingNode, result);
    return result;
  }
  getValueEnumProposals(entry, existingNode, result) {
    if (entry.values) {
      for (const value of entry.values) {
        let insertString = value.name;
        let insertTextFormat;
        if (endsWith(insertString, ")")) {
          const from = insertString.lastIndexOf("(");
          if (from !== -1) {
            insertString = insertString.substring(0, from + 1) + "$1" + insertString.substring(from + 1);
            insertTextFormat = SnippetFormat;
          }
        }
        let sortText = " " /* Enums */;
        if (startsWith(value.name, "-")) {
          sortText += "x" /* VendorPrefixed */;
        }
        const item = {
          label: value.name,
          documentation: getEntryDescription(value, this.doesSupportMarkdown()),
          tags: isDeprecated(entry) ? [CompletionItemTag.Deprecated] : [],
          textEdit: TextEdit.replace(this.getCompletionRange(existingNode), insertString),
          sortText,
          kind: CompletionItemKind.Value,
          insertTextFormat
        };
        result.items.push(item);
      }
    }
    return result;
  }
  getCSSWideKeywordProposals(entry, existingNode, result) {
    for (const keywords in cssWideKeywords) {
      result.items.push({
        label: keywords,
        documentation: cssWideKeywords[keywords],
        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), keywords),
        kind: CompletionItemKind.Value
      });
    }
    for (const func in cssWideFunctions) {
      const insertText = moveCursorInsideParenthesis(func);
      result.items.push({
        label: func,
        documentation: cssWideFunctions[func],
        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), insertText),
        kind: CompletionItemKind.Function,
        insertTextFormat: SnippetFormat,
        command: startsWith(func, "var") ? retriggerCommand : void 0
      });
    }
    return result;
  }
  getCompletionsForInterpolation(node, result) {
    if (this.offset >= node.offset + 2) {
      this.getVariableProposals(null, result);
    }
    return result;
  }
  getVariableProposals(existingNode, result) {
    const symbols = this.getSymbolContext().findSymbolsAtOffset(this.offset, 2 /* Variable */);
    for (const symbol of symbols) {
      const insertText = startsWith(symbol.name, "--") ? `var(${symbol.name})` : symbol.name;
      const completionItem = {
        label: symbol.name,
        documentation: symbol.value ? getLimitedString(symbol.value) : symbol.value,
        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), insertText),
        kind: CompletionItemKind.Variable,
        sortText: "z" /* Variable */
      };
      if (typeof completionItem.documentation === "string" && isColorString(completionItem.documentation)) {
        completionItem.kind = CompletionItemKind.Color;
      }
      if (symbol.node.type === 62 /* FunctionParameter */) {
        const mixinNode = symbol.node.getParent();
        if (mixinNode.type === 34 /* MixinDeclaration */) {
          completionItem.detail = localize8("completion.argument", "argument from '{0}'", mixinNode.getName());
        }
      }
      result.items.push(completionItem);
    }
    return result;
  }
  getVariableProposalsForCSSVarFunction(result) {
    const allReferencedVariables = new Set();
    this.styleSheet.acceptVisitor(new VariableCollector(allReferencedVariables, this.offset));
    const symbols = this.getSymbolContext().findSymbolsAtOffset(this.offset, 2 /* Variable */);
    for (const symbol of symbols) {
      if (startsWith(symbol.name, "--")) {
        const completionItem = {
          label: symbol.name,
          documentation: symbol.value ? getLimitedString(symbol.value) : symbol.value,
          textEdit: TextEdit.replace(this.getCompletionRange(null), symbol.name),
          kind: CompletionItemKind.Variable
        };
        if (typeof completionItem.documentation === "string" && isColorString(completionItem.documentation)) {
          completionItem.kind = CompletionItemKind.Color;
        }
        result.items.push(completionItem);
      }
      allReferencedVariables.remove(symbol.name);
    }
    for (const name of allReferencedVariables.getEntries()) {
      if (startsWith(name, "--")) {
        const completionItem = {
          label: name,
          textEdit: TextEdit.replace(this.getCompletionRange(null), name),
          kind: CompletionItemKind.Variable
        };
        result.items.push(completionItem);
      }
    }
    return result;
  }
  getUnitProposals(entry, existingNode, result) {
    let currentWord = "0";
    if (this.currentWord.length > 0) {
      const numMatch = this.currentWord.match(/^-?\d[\.\d+]*/);
      if (numMatch) {
        currentWord = numMatch[0];
        result.isIncomplete = currentWord.length === this.currentWord.length;
      }
    } else if (this.currentWord.length === 0) {
      result.isIncomplete = true;
    }
    if (existingNode && existingNode.parent && existingNode.parent.type === 24 /* Term */) {
      existingNode = existingNode.getParent();
    }
    if (entry.restrictions) {
      for (const restriction of entry.restrictions) {
        const units2 = units[restriction];
        if (units2) {
          for (const unit of units2) {
            const insertText = currentWord + unit;
            result.items.push({
              label: insertText,
              textEdit: TextEdit.replace(this.getCompletionRange(existingNode), insertText),
              kind: CompletionItemKind.Unit
            });
          }
        }
      }
    }
    return result;
  }
  getCompletionRange(existingNode) {
    if (existingNode && existingNode.offset <= this.offset && this.offset <= existingNode.end) {
      const end = existingNode.end !== -1 ? this.textDocument.positionAt(existingNode.end) : this.position;
      const start = this.textDocument.positionAt(existingNode.offset);
      if (start.line === end.line) {
        return Range.create(start, end);
      }
    }
    return this.defaultReplaceRange;
  }
  getColorProposals(entry, existingNode, result) {
    for (const color in colors) {
      result.items.push({
        label: color,
        documentation: colors[color],
        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), color),
        kind: CompletionItemKind.Color
      });
    }
    for (const color in colorKeywords) {
      result.items.push({
        label: color,
        documentation: colorKeywords[color],
        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), color),
        kind: CompletionItemKind.Value
      });
    }
    const colorValues = new Set();
    this.styleSheet.acceptVisitor(new ColorValueCollector(colorValues, this.offset));
    for (const color of colorValues.getEntries()) {
      result.items.push({
        label: color,
        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), color),
        kind: CompletionItemKind.Color
      });
    }
    for (const p of colorFunctions) {
      let tabStop = 1;
      const replaceFunction = (_match, p1) => "${" + tabStop++ + ":" + p1 + "}";
      const insertText = p.func.replace(/\[?\$(\w+)\]?/g, replaceFunction);
      result.items.push({
        label: p.func.substr(0, p.func.indexOf("(")),
        detail: p.func,
        documentation: p.desc,
        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), insertText),
        insertTextFormat: SnippetFormat,
        kind: CompletionItemKind.Function
      });
    }
    return result;
  }
  getPositionProposals(entry, existingNode, result) {
    for (const position in positionKeywords) {
      result.items.push({
        label: position,
        documentation: positionKeywords[position],
        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), position),
        kind: CompletionItemKind.Value
      });
    }
    return result;
  }
  getRepeatStyleProposals(entry, existingNode, result) {
    for (const repeat in repeatStyleKeywords) {
      result.items.push({
        label: repeat,
        documentation: repeatStyleKeywords[repeat],
        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), repeat),
        kind: CompletionItemKind.Value
      });
    }
    return result;
  }
  getLineStyleProposals(entry, existingNode, result) {
    for (const lineStyle in lineStyleKeywords) {
      result.items.push({
        label: lineStyle,
        documentation: lineStyleKeywords[lineStyle],
        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), lineStyle),
        kind: CompletionItemKind.Value
      });
    }
    return result;
  }
  getLineWidthProposals(entry, existingNode, result) {
    for (const lineWidth of lineWidthKeywords) {
      result.items.push({
        label: lineWidth,
        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), lineWidth),
        kind: CompletionItemKind.Value
      });
    }
    return result;
  }
  getGeometryBoxProposals(entry, existingNode, result) {
    for (const box in geometryBoxKeywords) {
      result.items.push({
        label: box,
        documentation: geometryBoxKeywords[box],
        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), box),
        kind: CompletionItemKind.Value
      });
    }
    return result;
  }
  getBoxProposals(entry, existingNode, result) {
    for (const box in boxKeywords) {
      result.items.push({
        label: box,
        documentation: boxKeywords[box],
        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), box),
        kind: CompletionItemKind.Value
      });
    }
    return result;
  }
  getImageProposals(entry, existingNode, result) {
    for (const image in imageFunctions) {
      const insertText = moveCursorInsideParenthesis(image);
      result.items.push({
        label: image,
        documentation: imageFunctions[image],
        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), insertText),
        kind: CompletionItemKind.Function,
        insertTextFormat: image !== insertText ? SnippetFormat : void 0
      });
    }
    return result;
  }
  getTimingFunctionProposals(entry, existingNode, result) {
    for (const timing in transitionTimingFunctions) {
      const insertText = moveCursorInsideParenthesis(timing);
      result.items.push({
        label: timing,
        documentation: transitionTimingFunctions[timing],
        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), insertText),
        kind: CompletionItemKind.Function,
        insertTextFormat: timing !== insertText ? SnippetFormat : void 0
      });
    }
    return result;
  }
  getBasicShapeProposals(entry, existingNode, result) {
    for (const shape in basicShapeFunctions) {
      const insertText = moveCursorInsideParenthesis(shape);
      result.items.push({
        label: shape,
        documentation: basicShapeFunctions[shape],
        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), insertText),
        kind: CompletionItemKind.Function,
        insertTextFormat: shape !== insertText ? SnippetFormat : void 0
      });
    }
    return result;
  }
  getCompletionsForStylesheet(result) {
    const node = this.styleSheet.findFirstChildBeforeOffset(this.offset);
    if (!node) {
      return this.getCompletionForTopLevel(result);
    }
    if (node instanceof RuleSet) {
      return this.getCompletionsForRuleSet(node, result);
    }
    if (node instanceof Supports) {
      return this.getCompletionsForSupports(node, result);
    }
    return result;
  }
  getCompletionForTopLevel(result) {
    this.cssDataManager.getAtDirectives().forEach((entry) => {
      result.items.push({
        label: entry.name,
        textEdit: TextEdit.replace(this.getCompletionRange(null), entry.name),
        documentation: getEntryDescription(entry, this.doesSupportMarkdown()),
        tags: isDeprecated(entry) ? [CompletionItemTag.Deprecated] : [],
        kind: CompletionItemKind.Keyword
      });
    });
    this.getCompletionsForSelector(null, false, result);
    return result;
  }
  getCompletionsForRuleSet(ruleSet, result) {
    const declarations = ruleSet.getDeclarations();
    const isAfter = declarations && declarations.endsWith("}") && this.offset >= declarations.end;
    if (isAfter) {
      return this.getCompletionForTopLevel(result);
    }
    const isInSelectors = !declarations || this.offset <= declarations.offset;
    if (isInSelectors) {
      return this.getCompletionsForSelector(ruleSet, ruleSet.isNested(), result);
    }
    return this.getCompletionsForDeclarations(ruleSet.getDeclarations(), result);
  }
  getCompletionsForSelector(ruleSet, isNested, result) {
    const existingNode = this.findInNodePath(17 /* PseudoSelector */, 15 /* IdentifierSelector */, 14 /* ClassSelector */, 16 /* ElementNameSelector */);
    if (!existingNode && this.hasCharacterAtPosition(this.offset - this.currentWord.length - 1, ":")) {
      this.currentWord = ":" + this.currentWord;
      if (this.hasCharacterAtPosition(this.offset - this.currentWord.length - 1, ":")) {
        this.currentWord = ":" + this.currentWord;
      }
      this.defaultReplaceRange = Range.create(Position.create(this.position.line, this.position.character - this.currentWord.length), this.position);
    }
    const pseudoClasses = this.cssDataManager.getPseudoClasses();
    pseudoClasses.forEach((entry) => {
      const insertText = moveCursorInsideParenthesis(entry.name);
      const item = {
        label: entry.name,
        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), insertText),
        documentation: getEntryDescription(entry, this.doesSupportMarkdown()),
        tags: isDeprecated(entry) ? [CompletionItemTag.Deprecated] : [],
        kind: CompletionItemKind.Function,
        insertTextFormat: entry.name !== insertText ? SnippetFormat : void 0
      };
      if (startsWith(entry.name, ":-")) {
        item.sortText = "x" /* VendorPrefixed */;
      }
      result.items.push(item);
    });
    const pseudoElements = this.cssDataManager.getPseudoElements();
    pseudoElements.forEach((entry) => {
      const insertText = moveCursorInsideParenthesis(entry.name);
      const item = {
        label: entry.name,
        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), insertText),
        documentation: getEntryDescription(entry, this.doesSupportMarkdown()),
        tags: isDeprecated(entry) ? [CompletionItemTag.Deprecated] : [],
        kind: CompletionItemKind.Function,
        insertTextFormat: entry.name !== insertText ? SnippetFormat : void 0
      };
      if (startsWith(entry.name, "::-")) {
        item.sortText = "x" /* VendorPrefixed */;
      }
      result.items.push(item);
    });
    if (!isNested) {
      for (const entry of html5Tags) {
        result.items.push({
          label: entry,
          textEdit: TextEdit.replace(this.getCompletionRange(existingNode), entry),
          kind: CompletionItemKind.Keyword
        });
      }
      for (const entry of svgElements) {
        result.items.push({
          label: entry,
          textEdit: TextEdit.replace(this.getCompletionRange(existingNode), entry),
          kind: CompletionItemKind.Keyword
        });
      }
    }
    const visited = {};
    visited[this.currentWord] = true;
    const docText = this.textDocument.getText();
    this.styleSheet.accept((n) => {
      if (n.type === 5 /* SimpleSelector */ && n.length > 0) {
        const selector = docText.substr(n.offset, n.length);
        if (selector.charAt(0) === "." && !visited[selector]) {
          visited[selector] = true;
          result.items.push({
            label: selector,
            textEdit: TextEdit.replace(this.getCompletionRange(existingNode), selector),
            kind: CompletionItemKind.Keyword
          });
        }
        return false;
      }
      return true;
    });
    if (ruleSet && ruleSet.isNested()) {
      const selector = ruleSet.getSelectors().findFirstChildBeforeOffset(this.offset);
      if (selector && ruleSet.getSelectors().getChildren().indexOf(selector) === 0) {
        this.getPropertyProposals(null, result);
      }
    }
    return result;
  }
  getCompletionsForDeclarations(declarations, result) {
    if (!declarations || this.offset === declarations.offset) {
      return result;
    }
    const node = declarations.findFirstChildBeforeOffset(this.offset);
    if (!node) {
      return this.getCompletionsForDeclarationProperty(null, result);
    }
    if (node instanceof AbstractDeclaration) {
      const declaration = node;
      if (!isDefined(declaration.colonPosition) || this.offset <= declaration.colonPosition) {
        return this.getCompletionsForDeclarationProperty(declaration, result);
      } else if (isDefined(declaration.semicolonPosition) && declaration.semicolonPosition < this.offset) {
        if (this.offset === declaration.semicolonPosition + 1) {
          return result;
        }
        return this.getCompletionsForDeclarationProperty(null, result);
      }
      if (declaration instanceof Declaration) {
        return this.getCompletionsForDeclarationValue(declaration, result);
      }
    } else if (node instanceof ExtendsReference) {
      this.getCompletionsForExtendsReference(node, null, result);
    } else if (this.currentWord && this.currentWord[0] === "@") {
      this.getCompletionsForDeclarationProperty(null, result);
    } else if (node instanceof RuleSet) {
      this.getCompletionsForDeclarationProperty(null, result);
    }
    return result;
  }
  getCompletionsForVariableDeclaration(declaration, result) {
    if (this.offset && isDefined(declaration.colonPosition) && this.offset > declaration.colonPosition) {
      this.getVariableProposals(declaration.getValue() || null, result);
    }
    return result;
  }
  getCompletionsForExpression(expression, result) {
    const parent = expression.getParent();
    if (parent instanceof FunctionArgument) {
      this.getCompletionsForFunctionArgument(parent, parent.getParent(), result);
      return result;
    }
    const declaration = expression.findParent(19 /* Declaration */);
    if (!declaration) {
      this.getTermProposals(void 0, null, result);
      return result;
    }
    const node = expression.findChildAtOffset(this.offset, true);
    if (!node) {
      return this.getCompletionsForDeclarationValue(declaration, result);
    }
    if (node instanceof NumericValue || node instanceof Identifier) {
      return this.getCompletionsForDeclarationValue(declaration, result);
    }
    return result;
  }
  getCompletionsForFunctionArgument(arg, func, result) {
    const identifier = func.getIdentifier();
    if (identifier && identifier.matches("var")) {
      if (!func.getArguments().hasChildren() || func.getArguments().getChild(0) === arg) {
        this.getVariableProposalsForCSSVarFunction(result);
      }
    }
    return result;
  }
  getCompletionsForFunctionDeclaration(decl, result) {
    const declarations = decl.getDeclarations();
    if (declarations && this.offset > declarations.offset && this.offset < declarations.end) {
      this.getTermProposals(void 0, null, result);
    }
    return result;
  }
  getCompletionsForMixinReference(ref, result) {
    const allMixins = this.getSymbolContext().findSymbolsAtOffset(this.offset, 0 /* Mixin */);
    for (const mixinSymbol of allMixins) {
      if (mixinSymbol.node instanceof MixinDeclaration) {
        result.items.push(this.makeTermProposal(mixinSymbol, mixinSymbol.node.getParameters(), null));
      }
    }
    const identifierNode = ref.getIdentifier() || null;
    this.completionParticipants.forEach((participant) => {
      if (participant.onCssMixinReference) {
        participant.onCssMixinReference({
          mixinName: this.currentWord,
          range: this.getCompletionRange(identifierNode)
        });
      }
    });
    return result;
  }
  getTermProposals(entry, existingNode, result) {
    const allFunctions = this.getSymbolContext().findSymbolsAtOffset(this.offset, 3 /* Function */);
    for (const functionSymbol of allFunctions) {
      if (functionSymbol.node instanceof FunctionDeclaration) {
        result.items.push(this.makeTermProposal(functionSymbol, functionSymbol.node.getParameters(), existingNode));
      }
    }
    return result;
  }
  makeTermProposal(symbol, parameters, existingNode) {
    const decl = symbol.node;
    const params = parameters.getChildren().map((c) => {
      return c instanceof FunctionParameter ? c.getName() : c.getText();
    });
    const insertText = symbol.name + "(" + params.map((p, index) => "${" + (index + 1) + ":" + p + "}").join(", ") + ")";
    return {
      label: symbol.name,
      detail: symbol.name + "(" + params.join(", ") + ")",
      textEdit: TextEdit.replace(this.getCompletionRange(existingNode), insertText),
      insertTextFormat: SnippetFormat,
      kind: CompletionItemKind.Function,
      sortText: "y" /* Term */
    };
  }
  getCompletionsForSupportsCondition(supportsCondition, result) {
    const child = supportsCondition.findFirstChildBeforeOffset(this.offset);
    if (child) {
      if (child instanceof Declaration) {
        if (!isDefined(child.colonPosition) || this.offset <= child.colonPosition) {
          return this.getCompletionsForDeclarationProperty(child, result);
        } else {
          return this.getCompletionsForDeclarationValue(child, result);
        }
      } else if (child instanceof SupportsCondition) {
        return this.getCompletionsForSupportsCondition(child, result);
      }
    }
    if (isDefined(supportsCondition.lParent) && this.offset > supportsCondition.lParent && (!isDefined(supportsCondition.rParent) || this.offset <= supportsCondition.rParent)) {
      return this.getCompletionsForDeclarationProperty(null, result);
    }
    return result;
  }
  getCompletionsForSupports(supports, result) {
    const declarations = supports.getDeclarations();
    const inInCondition = !declarations || this.offset <= declarations.offset;
    if (inInCondition) {
      const child = supports.findFirstChildBeforeOffset(this.offset);
      if (child instanceof SupportsCondition) {
        return this.getCompletionsForSupportsCondition(child, result);
      }
      return result;
    }
    return this.getCompletionForTopLevel(result);
  }
  getCompletionsForExtendsReference(extendsRef, existingNode, result) {
    return result;
  }
  getCompletionForUriLiteralValue(uriLiteralNode, result) {
    let uriValue;
    let position;
    let range;
    if (!uriLiteralNode.hasChildren()) {
      uriValue = "";
      position = this.position;
      const emptyURIValuePosition = this.textDocument.positionAt(uriLiteralNode.offset + "url(".length);
      range = Range.create(emptyURIValuePosition, emptyURIValuePosition);
    } else {
      const uriValueNode = uriLiteralNode.getChild(0);
      uriValue = uriValueNode.getText();
      position = this.position;
      range = this.getCompletionRange(uriValueNode);
    }
    this.completionParticipants.forEach((participant) => {
      if (participant.onCssURILiteralValue) {
        participant.onCssURILiteralValue({
          uriValue,
          position,
          range
        });
      }
    });
    return result;
  }
  getCompletionForImportPath(importPathNode, result) {
    this.completionParticipants.forEach((participant) => {
      if (participant.onCssImportPath) {
        participant.onCssImportPath({
          pathValue: importPathNode.getText(),
          position: this.position,
          range: this.getCompletionRange(importPathNode)
        });
      }
    });
    return result;
  }
  hasCharacterAtPosition(offset, char) {
    const text = this.textDocument.getText();
    return offset >= 0 && offset < text.length && text.charAt(offset) === char;
  }
  doesSupportMarkdown() {
    var _a2, _b, _c;
    if (!isDefined(this.supportsMarkdown)) {
      if (!isDefined(this.lsOptions.clientCapabilities)) {
        this.supportsMarkdown = true;
        return this.supportsMarkdown;
      }
      const documentationFormat = (_c = (_b = (_a2 = this.lsOptions.clientCapabilities.textDocument) == null ? void 0 : _a2.completion) == null ? void 0 : _b.completionItem) == null ? void 0 : _c.documentationFormat;
      this.supportsMarkdown = Array.isArray(documentationFormat) && documentationFormat.indexOf(MarkupKind.Markdown) !== -1;
    }
    return this.supportsMarkdown;
  }
};
function isDeprecated(entry) {
  if (entry.status && (entry.status === "nonstandard" || entry.status === "obsolete")) {
    return true;
  }
  return false;
}
var Set = class {
  constructor() {
    this.entries = {};
  }
  add(entry) {
    this.entries[entry] = true;
  }
  remove(entry) {
    delete this.entries[entry];
  }
  getEntries() {
    return Object.keys(this.entries);
  }
};
function moveCursorInsideParenthesis(text) {
  return text.replace(/\(\)$/, "($1)");
}
function collectValues(styleSheet, declaration) {
  const fullPropertyName = declaration.getFullPropertyName();
  const entries = new Set();
  function visitValue(node) {
    if (node instanceof Identifier || node instanceof NumericValue || node instanceof HexColorValue) {
      entries.add(node.getText());
    }
    return true;
  }
  function matchesProperty(decl) {
    const propertyName = decl.getFullPropertyName();
    return fullPropertyName === propertyName;
  }
  function vistNode(node) {
    if (node instanceof Declaration && node !== declaration) {
      if (matchesProperty(node)) {
        const value = node.getValue();
        if (value) {
          value.accept(visitValue);
        }
      }
    }
    return true;
  }
  styleSheet.accept(vistNode);
  return entries;
}
var ColorValueCollector = class {
  constructor(entries, currentOffset) {
    this.entries = entries;
    this.currentOffset = currentOffset;
  }
  visitNode(node) {
    if (node instanceof HexColorValue || node instanceof Function && isColorConstructor(node)) {
      if (this.currentOffset < node.offset || node.end < this.currentOffset) {
        this.entries.add(node.getText());
      }
    }
    return true;
  }
};
var VariableCollector = class {
  constructor(entries, currentOffset) {
    this.entries = entries;
    this.currentOffset = currentOffset;
  }
  visitNode(node) {
    if (node instanceof Identifier && node.isCustomProperty) {
      if (this.currentOffset < node.offset || node.end < this.currentOffset) {
        this.entries.add(node.getText());
      }
    }
    return true;
  }
};
function getCurrentWord(document, offset) {
  let i = offset - 1;
  const text = document.getText();
  while (i >= 0 && ' 	\n\r":{[()]},*>+'.indexOf(text.charAt(i)) === -1) {
    i--;
  }
  return text.substring(i + 1, offset);
}
function isColorString(s) {
  return s.toLowerCase() in colors || /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(s);
}

// src/vscode-css-languageservice/services/postCSSCompletion.ts
import * as nls9 from "vscode-nls";
var localize9 = nls9.loadMessageBundle();
var _PostCSSCompletion = class extends CSSCompletion {
  constructor(lsServiceOptions, cssDataManager) {
    super("$", lsServiceOptions, cssDataManager);
    addReferencesToDocumentation(_PostCSSCompletion.postcssModuleLoaders);
    addReferencesToDocumentation(_PostCSSCompletion.postcssModuleBuiltIns);
  }
  isImportPathParent(type) {
    return type === 79 /* Forward */ || type === 77 /* Use */ || super.isImportPathParent(type);
  }
  getCompletionForImportPath(importPathNode, result) {
    const parentType = importPathNode.getParent().type;
    if (parentType === 79 /* Forward */ || parentType === 77 /* Use */) {
      for (const p of _PostCSSCompletion.postcssModuleBuiltIns) {
        const item = {
          label: p.label,
          documentation: p.documentation,
          textEdit: TextEdit.replace(this.getCompletionRange(importPathNode), `'${p.label}'`),
          kind: CompletionItemKind.Module
        };
        result.items.push(item);
      }
    }
    return super.getCompletionForImportPath(importPathNode, result);
  }
  createReplaceFunction() {
    let tabStopCounter = 1;
    return (_match, p1) => {
      return "${" + tabStopCounter++ + ":" + p1 + "}";
    };
  }
  createFunctionProposals(proposals, existingNode, sortToEnd, result) {
    for (const p of proposals) {
      const insertText = p.func.replace(/\[?\$(\w+)\]?/g, this.createReplaceFunction());
      const label = p.func.substr(0, p.func.indexOf("("));
      const item = {
        label,
        detail: p.func,
        documentation: p.desc,
        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), insertText),
        insertTextFormat: InsertTextFormat.Snippet,
        kind: CompletionItemKind.Function
      };
      if (sortToEnd) {
        item.sortText = "z";
      }
      result.items.push(item);
    }
    return result;
  }
  getCompletionsForSelector(ruleSet, isNested, result) {
    this.createFunctionProposals(_PostCSSCompletion.selectorFuncs, null, true, result);
    return super.getCompletionsForSelector(ruleSet, isNested, result);
  }
  getTermProposals(entry, existingNode, result) {
    let functions = _PostCSSCompletion.builtInFuncs;
    if (entry) {
      functions = functions.filter((f2) => !f2.type || !entry.restrictions || entry.restrictions.indexOf(f2.type) !== -1);
    }
    this.createFunctionProposals(functions, existingNode, true, result);
    return super.getTermProposals(entry, existingNode, result);
  }
  getColorProposals(entry, existingNode, result) {
    this.createFunctionProposals(_PostCSSCompletion.colorProposals, existingNode, false, result);
    return super.getColorProposals(entry, existingNode, result);
  }
  getCompletionsForDeclarationProperty(declaration, result) {
    this.getCompletionForAtDirectives(result);
    this.getCompletionsForSelector(null, true, result);
    return super.getCompletionsForDeclarationProperty(declaration, result);
  }
  getCompletionsForExtendsReference(_extendsRef, existingNode, result) {
    const symbols = this.getSymbolContext().findSymbolsAtOffset(this.offset, 1 /* Rule */);
    for (const symbol of symbols) {
      const suggest = {
        label: symbol.name,
        textEdit: TextEdit.replace(this.getCompletionRange(existingNode), symbol.name),
        kind: CompletionItemKind.Function
      };
      result.items.push(suggest);
    }
    return result;
  }
  getCompletionForAtDirectives(result) {
    result.items.push(..._PostCSSCompletion.postcssAtDirectives);
    return result;
  }
  getCompletionForTopLevel(result) {
    this.getCompletionForAtDirectives(result);
    this.getCompletionForModuleLoaders(result);
    super.getCompletionForTopLevel(result);
    return result;
  }
  getCompletionForModuleLoaders(result) {
    result.items.push(..._PostCSSCompletion.postcssModuleLoaders);
    return result;
  }
};
var PostCSSCompletion = _PostCSSCompletion;
PostCSSCompletion.colorProposals = [
  { func: "color($colorSpace $arg1 $arg2 $arg3)", desc: localize9("postcss.builtin.color", "The color function takes parameters specifying a color, in an explicitly listed color space.") }
];
PostCSSCompletion.selectorFuncs = [];
PostCSSCompletion.builtInFuncs = [
  { func: "env($variable)", desc: localize9("postcss.builtin.env", "The env() CSS function can be used to insert the value of a user agent-defined environment variable into your CSS, in a similar fashion to the var() function and custom properties.") }
];
PostCSSCompletion.postcssAtDirectives = [
  {
    label: "@nest",
    documentation: localize9("postcss.builtin.@nest", "Inherits the styles of another selector."),
    kind: CompletionItemKind.Keyword
  }
];
PostCSSCompletion.postcssModuleLoaders = [];
PostCSSCompletion.postcssModuleBuiltIns = [
  {
    label: "sass:math",
    documentation: localize9("postcss.builtin.sass:math", "Provides functions that operate on numbers."),
    references: [{ name: "Sass documentation", url: "https://sass-lang.com/documentation/modules/math" }]
  },
  {
    label: "sass:string",
    documentation: localize9("postcss.builtin.sass:string", "Makes it easy to combine, search, or split apart strings."),
    references: [{ name: "Sass documentation", url: "https://sass-lang.com/documentation/modules/string" }]
  },
  {
    label: "sass:color",
    documentation: localize9("postcss.builtin.sass:color", "Generates new colors based on existing ones, making it easy to build color themes."),
    references: [{ name: "Sass documentation", url: "https://sass-lang.com/documentation/modules/color" }]
  },
  {
    label: "sass:list",
    documentation: localize9("postcss.builtin.sass:list", "Lets you access and modify values in lists."),
    references: [{ name: "Sass documentation", url: "https://sass-lang.com/documentation/modules/list" }]
  },
  {
    label: "sass:map",
    documentation: localize9("postcss.builtin.sass:map", "Makes it possible to look up the value associated with a key in a map, and much more."),
    references: [{ name: "Sass documentation", url: "https://sass-lang.com/documentation/modules/map" }]
  },
  {
    label: "sass:selector",
    documentation: localize9("postcss.builtin.sass:selector", "Provides access to Sass\u2019s powerful selector engine."),
    references: [{ name: "Sass documentation", url: "https://sass-lang.com/documentation/modules/selector" }]
  },
  {
    label: "sass:meta",
    documentation: localize9("postcss.builtin.sass:meta", "Exposes the details of Sass\u2019s inner workings."),
    references: [{ name: "Sass documentation", url: "https://sass-lang.com/documentation/modules/meta" }]
  }
];
function addReferencesToDocumentation(items) {
  items.forEach((i) => {
    if (i.documentation && i.references && i.references.length > 0) {
      const markdownDoc = typeof i.documentation === "string" ? { kind: "markdown", value: i.documentation } : { kind: "markdown", value: i.documentation.value };
      markdownDoc.value += "\n\n";
      markdownDoc.value += i.references.map((r) => {
        return `[${r.name}](${r.url})`;
      }).join(" | ");
      i.documentation = markdownDoc;
    }
  });
}

// src/vscode-css-languageservice/services/cssNavigation.ts
import * as nls10 from "vscode-nls";
var localize10 = nls10.loadMessageBundle();
var startsWithSchemeRegex = /^\w+:\/\//;
var startsWithData = /^data:/;
var CSSNavigation = class {
  constructor(fileSystemProvider, resolveModuleReferences) {
    this.fileSystemProvider = fileSystemProvider;
    this.resolveModuleReferences = resolveModuleReferences;
  }
  findDefinition(document, position, stylesheet) {
    const symbols = new Symbols(stylesheet);
    const offset = document.offsetAt(position);
    const node = getNodeAtOffset(stylesheet, offset);
    if (!node) {
      return null;
    }
    const symbol = symbols.findSymbolFromNode(node);
    if (!symbol) {
      return null;
    }
    return {
      uri: document.uri,
      range: getRange(symbol.node, document)
    };
  }
  findReferences(document, position, stylesheet) {
    const highlights = this.findDocumentHighlights(document, position, stylesheet);
    return highlights.map((h) => {
      return {
        uri: document.uri,
        range: h.range
      };
    });
  }
  findDocumentHighlights(document, position, stylesheet) {
    const result = [];
    const offset = document.offsetAt(position);
    let node = getNodeAtOffset(stylesheet, offset);
    if (!node || node.type === 2 /* Stylesheet */ || node.type === 20 /* Declarations */) {
      return result;
    }
    if (node.type === 1 /* Identifier */ && node.parent && node.parent.type === 14 /* ClassSelector */) {
      node = node.parent;
    }
    const symbols = new Symbols(stylesheet);
    const symbol = symbols.findSymbolFromNode(node);
    const name = node.getText();
    stylesheet.accept((candidate) => {
      if (symbol) {
        if (symbols.matchesSymbol(candidate, symbol)) {
          result.push({
            kind: getHighlightKind(candidate),
            range: getRange(candidate, document)
          });
          return false;
        }
      } else if (node && node.type === candidate.type && candidate.matches(name)) {
        result.push({
          kind: getHighlightKind(candidate),
          range: getRange(candidate, document)
        });
      }
      return true;
    });
    return result;
  }
  isRawStringDocumentLinkNode(node) {
    return node.type === 54 /* Import */;
  }
  findDocumentLinks(document, stylesheet, documentContext) {
    const linkData = this.findUnresolvedLinks(document, stylesheet);
    const resolvedLinks = [];
    for (const data of linkData) {
      const link = data.link;
      const target = link.target;
      if (!target || startsWithData.test(target)) {
      } else if (startsWithSchemeRegex.test(target)) {
        resolvedLinks.push(link);
      } else {
        const resolved = documentContext.resolveReference(target, document.uri);
        if (resolved) {
          link.target = resolved;
        }
        resolvedLinks.push(link);
      }
    }
    return resolvedLinks;
  }
  async findDocumentLinks2(document, stylesheet, documentContext) {
    const linkData = this.findUnresolvedLinks(document, stylesheet);
    const resolvedLinks = [];
    for (const data of linkData) {
      const link = data.link;
      const target = link.target;
      if (!target || startsWithData.test(target)) {
      } else if (startsWithSchemeRegex.test(target)) {
        resolvedLinks.push(link);
      } else {
        const resolvedTarget = await this.resolveRelativeReference(target, document.uri, documentContext, data.isRawLink);
        if (resolvedTarget !== void 0) {
          link.target = resolvedTarget;
          resolvedLinks.push(link);
        }
      }
    }
    return resolvedLinks;
  }
  findUnresolvedLinks(document, stylesheet) {
    const result = [];
    const collect = (uriStringNode) => {
      let rawUri = uriStringNode.getText();
      const range = getRange(uriStringNode, document);
      if (range.start.line === range.end.line && range.start.character === range.end.character) {
        return;
      }
      if (startsWith(rawUri, `'`) || startsWith(rawUri, `"`)) {
        rawUri = rawUri.slice(1, -1);
      }
      const isRawLink = uriStringNode.parent ? this.isRawStringDocumentLinkNode(uriStringNode.parent) : false;
      result.push({ link: { target: rawUri, range }, isRawLink });
    };
    stylesheet.accept((candidate) => {
      if (candidate.type === 28 /* URILiteral */) {
        const first = candidate.getChild(0);
        if (first) {
          collect(first);
        }
        return false;
      }
      if (candidate.parent && this.isRawStringDocumentLinkNode(candidate.parent)) {
        const rawText = candidate.getText();
        if (startsWith(rawText, `'`) || startsWith(rawText, `"`)) {
          collect(candidate);
        }
        return false;
      }
      return true;
    });
    return result;
  }
  findSymbolInformations(document, stylesheet) {
    const result = [];
    const addSymbolInformation = (name, kind, symbolNodeOrRange) => {
      const range = symbolNodeOrRange instanceof Node ? getRange(symbolNodeOrRange, document) : symbolNodeOrRange;
      const entry = {
        name,
        kind,
        location: Location.create(document.uri, range)
      };
      result.push(entry);
    };
    this.collectDocumentSymbols(document, stylesheet, addSymbolInformation);
    return result;
  }
  findDocumentSymbols(document, stylesheet) {
    const result = [];
    const parents = [];
    const addDocumentSymbol = (name, kind, symbolNodeOrRange, nameNodeOrRange, bodyNode) => {
      const range = symbolNodeOrRange instanceof Node ? getRange(symbolNodeOrRange, document) : symbolNodeOrRange;
      const selectionRange = (nameNodeOrRange instanceof Node ? getRange(nameNodeOrRange, document) : nameNodeOrRange) ?? Range.create(range.start, range.start);
      const entry = {
        name,
        kind,
        range,
        selectionRange
      };
      let top = parents.pop();
      while (top && !containsRange(top[1], range)) {
        top = parents.pop();
      }
      if (top) {
        const topSymbol = top[0];
        if (!topSymbol.children) {
          topSymbol.children = [];
        }
        topSymbol.children.push(entry);
        parents.push(top);
      } else {
        result.push(entry);
      }
      if (bodyNode) {
        parents.push([entry, getRange(bodyNode, document)]);
      }
    };
    this.collectDocumentSymbols(document, stylesheet, addDocumentSymbol);
    return result;
  }
  collectDocumentSymbols(document, stylesheet, collect) {
    stylesheet.accept((node) => {
      if (node instanceof RuleSet) {
        for (const selector of node.getSelectors().getChildren()) {
          if (selector instanceof Selector) {
            const range = Range.create(document.positionAt(selector.offset), document.positionAt(node.end));
            collect(selector.getText(), SymbolKind.Class, range, selector, node.getDeclarations());
          }
        }
      } else if (node instanceof VariableDeclaration) {
        collect(node.getName(), SymbolKind.Variable, node, node.getVariable(), void 0);
      } else if (node instanceof MixinDeclaration) {
        collect(node.getName(), SymbolKind.Method, node, node.getIdentifier(), node.getDeclarations());
      } else if (node instanceof FunctionDeclaration) {
        collect(node.getName(), SymbolKind.Function, node, node.getIdentifier(), node.getDeclarations());
      } else if (node instanceof Keyframe) {
        const name = localize10("literal.keyframes", "@keyframes {0}", node.getName());
        collect(name, SymbolKind.Class, node, node.getIdentifier(), node.getDeclarations());
      } else if (node instanceof FontFace) {
        const name = localize10("literal.fontface", "@font-face");
        collect(name, SymbolKind.Class, node, void 0, node.getDeclarations());
      } else if (node instanceof Media) {
        const mediaList = node.getChild(0);
        if (mediaList instanceof Medialist) {
          const name = "@media " + mediaList.getText();
          collect(name, SymbolKind.Module, node, mediaList, node.getDeclarations());
        }
      }
      return true;
    });
  }
  findDocumentColors(document, stylesheet) {
    const result = [];
    stylesheet.accept((node) => {
      const colorInfo = getColorInformation(node, document);
      if (colorInfo) {
        result.push(colorInfo);
      }
      return true;
    });
    return result;
  }
  getColorPresentations(document, stylesheet, color, range) {
    const result = [];
    const red256 = Math.round(color.red * 255), green256 = Math.round(color.green * 255), blue256 = Math.round(color.blue * 255);
    let label;
    if (color.alpha === 1) {
      label = `rgb(${red256}, ${green256}, ${blue256})`;
    } else {
      label = `rgba(${red256}, ${green256}, ${blue256}, ${color.alpha})`;
    }
    result.push({ label, textEdit: TextEdit.replace(range, label) });
    if (color.alpha === 1) {
      label = `#${toTwoDigitHex(red256)}${toTwoDigitHex(green256)}${toTwoDigitHex(blue256)}`;
    } else {
      label = `#${toTwoDigitHex(red256)}${toTwoDigitHex(green256)}${toTwoDigitHex(blue256)}${toTwoDigitHex(Math.round(color.alpha * 255))}`;
    }
    result.push({ label, textEdit: TextEdit.replace(range, label) });
    const hsl = hslFromColor(color);
    if (hsl.a === 1) {
      label = `hsl(${hsl.h}, ${Math.round(hsl.s * 100)}%, ${Math.round(hsl.l * 100)}%)`;
    } else {
      label = `hsla(${hsl.h}, ${Math.round(hsl.s * 100)}%, ${Math.round(hsl.l * 100)}%, ${hsl.a})`;
    }
    result.push({ label, textEdit: TextEdit.replace(range, label) });
    const hwb = hwbFromColor(color);
    if (hwb.a === 1) {
      label = `hwb(${hwb.h} ${Math.round(hwb.w * 100)}% ${Math.round(hwb.b * 100)}%)`;
    } else {
      label = `hwb(${hwb.h} ${Math.round(hwb.w * 100)}% ${Math.round(hwb.b * 100)}% / ${hwb.a})`;
    }
    result.push({ label, textEdit: TextEdit.replace(range, label) });
    return result;
  }
  doRename(document, position, newName, stylesheet) {
    const highlights = this.findDocumentHighlights(document, position, stylesheet);
    const edits = highlights.map((h) => TextEdit.replace(h.range, newName));
    return {
      changes: { [document.uri]: edits }
    };
  }
  async resolveModuleReference(ref, documentUri, documentContext) {
    if (startsWith(documentUri, "file://")) {
      const moduleName = getModuleNameFromPath(ref);
      const rootFolderUri = documentContext.resolveReference("/", documentUri);
      const documentFolderUri = dirname(documentUri);
      const modulePath = await this.resolvePathToModule(moduleName, documentFolderUri, rootFolderUri);
      if (modulePath) {
        const pathWithinModule = ref.substring(moduleName.length + 1);
        return joinPath(modulePath, pathWithinModule);
      }
    }
    return void 0;
  }
  async resolveRelativeReference(ref, documentUri, documentContext, isRawLink) {
    const relativeReference = documentContext.resolveReference(ref, documentUri);
    if (ref[0] === "~" && ref[1] !== "/" && this.fileSystemProvider) {
      ref = ref.substring(1);
      return await this.resolveModuleReference(ref, documentUri, documentContext) || relativeReference;
    }
    if (this.resolveModuleReferences) {
      if (relativeReference && await this.fileExists(relativeReference)) {
        return relativeReference;
      } else {
        return await this.resolveModuleReference(ref, documentUri, documentContext) || relativeReference;
      }
    }
    return relativeReference;
  }
  async resolvePathToModule(_moduleName, documentFolderUri, rootFolderUri) {
    const packPath = joinPath(documentFolderUri, "node_modules", _moduleName, "package.json");
    if (await this.fileExists(packPath)) {
      return dirname(packPath);
    } else if (rootFolderUri && documentFolderUri.startsWith(rootFolderUri) && documentFolderUri.length !== rootFolderUri.length) {
      return this.resolvePathToModule(_moduleName, dirname(documentFolderUri), rootFolderUri);
    }
    return void 0;
  }
  async fileExists(uri) {
    if (!this.fileSystemProvider) {
      return false;
    }
    try {
      const stat = await this.fileSystemProvider.stat(uri);
      if (stat.type === 0 /* Unknown */ && stat.size === -1) {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
};
function getColorInformation(node, document) {
  const color = getColorValue(node);
  if (color) {
    const range = getRange(node, document);
    return { color, range };
  }
  return null;
}
function getRange(node, document) {
  return Range.create(document.positionAt(node.offset), document.positionAt(node.end));
}
function containsRange(range, otherRange) {
  const otherStartLine = otherRange.start.line, otherEndLine = otherRange.end.line;
  const rangeStartLine = range.start.line, rangeEndLine = range.end.line;
  if (otherStartLine < rangeStartLine || otherEndLine < rangeStartLine) {
    return false;
  }
  if (otherStartLine > rangeEndLine || otherEndLine > rangeEndLine) {
    return false;
  }
  if (otherStartLine === rangeStartLine && otherRange.start.character < range.start.character) {
    return false;
  }
  if (otherEndLine === rangeEndLine && otherRange.end.character > range.end.character) {
    return false;
  }
  return true;
}
function getHighlightKind(node) {
  if (node.type === 4 /* Selector */) {
    return DocumentHighlightKind.Write;
  }
  if (node instanceof Identifier) {
    if (node.parent && node.parent instanceof Property) {
      if (node.isCustomProperty) {
        return DocumentHighlightKind.Write;
      }
    }
  }
  if (node.parent) {
    switch (node.parent.type) {
      case 57 /* FunctionDeclaration */:
      case 34 /* MixinDeclaration */:
      case 52 /* Keyframe */:
      case 37 /* VariableDeclaration */:
      case 62 /* FunctionParameter */:
        return DocumentHighlightKind.Write;
    }
  }
  return DocumentHighlightKind.Read;
}
function toTwoDigitHex(n) {
  const r = n.toString(16);
  return r.length !== 2 ? "0" + r : r;
}
function getModuleNameFromPath(path) {
  const firstSlash = path.indexOf("/");
  if (firstSlash === -1) {
    return "";
  }
  if (path[0] === "@") {
    const secondSlash = path.indexOf("/", firstSlash + 1);
    if (secondSlash === -1) {
      return path;
    }
    return path.substring(0, secondSlash);
  }
  return path.substring(0, firstSlash);
}

// src/vscode-css-languageservice/services/postCSSNavigation.ts
import { URI as URI2 } from "vscode-uri";
var PostCSSNavigation = class extends CSSNavigation {
  constructor(fileSystemProvider) {
    super(fileSystemProvider, true);
  }
  isRawStringDocumentLinkNode(node) {
    return super.isRawStringDocumentLinkNode(node) || node.type === 77 /* Use */ || node.type === 79 /* Forward */;
  }
  async resolveRelativeReference(ref, documentUri, documentContext, isRawLink) {
    if (startsWith(ref, "sass:")) {
      return void 0;
    }
    const target = await super.resolveRelativeReference(ref, documentUri, documentContext, isRawLink);
    if (this.fileSystemProvider && target && isRawLink) {
      const parsedUri = URI2.parse(target);
      try {
        const pathVariations = toPathVariations(parsedUri);
        if (pathVariations) {
          for (let j = 0; j < pathVariations.length; j++) {
            if (await this.fileExists(pathVariations[j])) {
              return pathVariations[j];
            }
          }
        }
      } catch (e) {
      }
    }
    return target;
    function toPathVariations(uri) {
      if (uri.path === "") {
        return void 0;
      }
      if (uri.path.endsWith(".scss") || uri.path.endsWith(".css")) {
        return void 0;
      }
      if (uri.path.endsWith("/")) {
        return [
          uri.with({ path: uri.path + "index.scss" }).toString(),
          uri.with({ path: uri.path + "_index.scss" }).toString()
        ];
      }
      const pathFragments = uri.path.split("/");
      const basename = pathFragments[pathFragments.length - 1];
      const pathWithoutBasename = uri.path.slice(0, -basename.length);
      if (basename.startsWith("_")) {
        if (uri.path.endsWith(".scss")) {
          return void 0;
        } else {
          return [uri.with({ path: uri.path + ".scss" }).toString()];
        }
      }
      const normalizedBasename = basename + ".scss";
      const documentUriWithBasename = (newBasename) => {
        return uri.with({ path: pathWithoutBasename + newBasename }).toString();
      };
      const normalizedPath = documentUriWithBasename(normalizedBasename);
      const underScorePath = documentUriWithBasename("_" + normalizedBasename);
      const indexPath = documentUriWithBasename(normalizedBasename.slice(0, -5) + "/index.scss");
      const indexUnderscoreUri = documentUriWithBasename(normalizedBasename.slice(0, -5) + "/_index.scss");
      const cssPath = documentUriWithBasename(normalizedBasename.slice(0, -5) + ".css");
      return [normalizedPath, underScorePath, indexPath, indexUnderscoreUri, cssPath];
    }
  }
};

// src/vscode-css-languageservice/cssLanguageService.ts
function createFacade(parser, completion, hover, navigation, codeActions, validation, cssDataManager) {
  return {
    configure: (settings) => {
      validation.configure(settings);
      completion.configure(settings == null ? void 0 : settings.completion);
      hover.configure(settings == null ? void 0 : settings.hover);
    },
    setDataProviders: cssDataManager.setDataProviders.bind(cssDataManager),
    doValidation: validation.doValidation.bind(validation),
    parseStylesheet: parser.parseStylesheet.bind(parser),
    doComplete: completion.doComplete.bind(completion),
    doComplete2: completion.doComplete2.bind(completion),
    setCompletionParticipants: completion.setCompletionParticipants.bind(completion),
    doHover: hover.doHover.bind(hover),
    findDefinition: navigation.findDefinition.bind(navigation),
    findReferences: navigation.findReferences.bind(navigation),
    findDocumentHighlights: navigation.findDocumentHighlights.bind(navigation),
    findDocumentLinks: navigation.findDocumentLinks.bind(navigation),
    findDocumentLinks2: navigation.findDocumentLinks2.bind(navigation),
    findDocumentSymbols: navigation.findDocumentSymbols.bind(navigation),
    doCodeActions: codeActions.doCodeActions.bind(codeActions),
    doCodeActions2: codeActions.doCodeActions2.bind(codeActions),
    findDocumentColors: navigation.findDocumentColors.bind(navigation),
    getColorPresentations: navigation.getColorPresentations.bind(navigation),
    doRename: navigation.doRename.bind(navigation),
    getFoldingRanges,
    getSelectionRanges
  };
}
var defaultLanguageServiceOptions = {};
function getPostCSSLanguageService(options = defaultLanguageServiceOptions) {
  const cssDataManager = new CSSDataManager(options);
  return createFacade(
    new PostCSSParser(),
    new PostCSSCompletion(options, cssDataManager),
    new CSSHover(options && options.clientCapabilities, cssDataManager),
    new PostCSSNavigation(options && options.fileSystemProvider),
    new CSSCodeActions(cssDataManager),
    new CSSValidation(cssDataManager),
    cssDataManager
  );
}

// src/languageModelCache.ts
function getLanguageModelCache(maxEntries, cleanupIntervalTimeInSec, parse) {
  let languageModels = {};
  let nModels = 0;
  let cleanupInterval = void 0;
  if (cleanupIntervalTimeInSec > 0) {
    cleanupInterval = setInterval(() => {
      const cutoffTime = Date.now() - cleanupIntervalTimeInSec * 1e3;
      const uris = Object.keys(languageModels);
      for (const uri of uris) {
        const languageModelInfo = languageModels[uri];
        if (languageModelInfo.cTime < cutoffTime) {
          delete languageModels[uri];
          nModels--;
        }
      }
    }, cleanupIntervalTimeInSec * 1e3);
  }
  return {
    get(document) {
      const version = document.version;
      const languageId = document.languageId;
      const languageModelInfo = languageModels[document.uri];
      if (languageModelInfo && languageModelInfo.version === version && languageModelInfo.languageId === languageId) {
        languageModelInfo.cTime = Date.now();
        return languageModelInfo.languageModel;
      }
      const languageModel = parse(document);
      languageModels[document.uri] = {
        languageModel,
        version,
        languageId,
        cTime: Date.now()
      };
      if (!languageModelInfo) {
        nModels++;
      }
      if (nModels === maxEntries) {
        let oldestTime = Number.MAX_VALUE;
        let oldestUri = null;
        for (const uri in languageModels) {
          const languageModelInfo2 = languageModels[uri];
          if (languageModelInfo2.cTime < oldestTime) {
            oldestUri = uri;
            oldestTime = languageModelInfo2.cTime;
          }
        }
        if (oldestUri) {
          delete languageModels[oldestUri];
          nModels--;
        }
      }
      return languageModel;
    },
    onDocumentRemoved(document) {
      const uri = document.uri;
      if (languageModels[uri]) {
        delete languageModels[uri];
        nModels--;
      }
    },
    dispose() {
      if (typeof cleanupInterval !== "undefined") {
        clearInterval(cleanupInterval);
        cleanupInterval = void 0;
        languageModels = {};
        nModels = 0;
      }
    }
  };
}

// src/index.ts
var connection = createConnection();
console.log = connection.console.log.bind(connection.console);
console.error = connection.console.error.bind(connection.console);
var documents = new TextDocuments(TextDocument9);
documents.listen(connection);
var stylesheets = getLanguageModelCache(
  10,
  60,
  (document) => getLanguageService(document).parseStylesheet(document)
);
var documentSettings = {};
var scopedSettingsSupport = false;
function getDocumentSettings(textDocument) {
  if (scopedSettingsSupport) {
    let promise = documentSettings[textDocument.uri];
    if (!promise) {
      const configRequestParam = {
        items: [
          { scopeUri: textDocument.uri, section: textDocument.languageId }
        ]
      };
      promise = connection.sendRequest(ConfigurationRequest.type, configRequestParam).then((s) => s[0]);
      documentSettings[textDocument.uri] = promise;
    }
    return promise;
  }
  return Promise.resolve(void 0);
}
documents.onDidClose((e) => {
  stylesheets.onDocumentRemoved(e.document);
});
connection.onShutdown(() => {
  stylesheets.dispose();
});
connection.onInitialize((params) => {
  const snippetSupport = params.capabilities && params.capabilities.textDocument && params.capabilities.textDocument.completion && params.capabilities.textDocument.completion.completionItem && params.capabilities.textDocument.completion.completionItem.snippetSupport;
  function getClientCapability(name, def) {
    const keys = name.split(".");
    let c = params.capabilities;
    for (let i = 0; c && i < keys.length; i++) {
      if (!c.hasOwnProperty(keys[i])) {
        return def;
      }
      c = c[keys[i]];
    }
    return c;
  }
  scopedSettingsSupport = !!getClientCapability(
    "workspace.configuration",
    false
  );
  return {
    capabilities: {
      textDocumentSync: TextDocumentSyncKind.Incremental,
      completionProvider: snippetSupport ? { resolveProvider: false } : null,
      hoverProvider: true,
      documentSymbolProvider: true,
      referencesProvider: true,
      definitionProvider: true,
      documentHighlightProvider: true,
      codeActionProvider: true,
      renameProvider: true,
      colorProvider: true
    }
  };
});
var languageServices = {
  css: getPostCSSLanguageService()
};
function getLanguageService(document) {
  const service = languageServices["css"];
  return service;
}
connection.onDidChangeConfiguration((change) => {
  updateConfiguration(change.settings);
});
function updateConfiguration(settings) {
  settings["css"] = settings["postcss"];
  for (const languageId in languageServices) {
    languageServices[languageId].configure(settings[languageId]);
  }
  documents.all().forEach(triggerValidation);
}
var pendingValidationRequests = {};
var validationDelayMs = 200;
documents.onDidChangeContent((change) => {
  triggerValidation(change.document);
});
documents.onDidClose((event) => {
  cleanPendingValidation(event.document);
  connection.sendDiagnostics({ uri: event.document.uri, diagnostics: [] });
});
function cleanPendingValidation(textDocument) {
  const request = pendingValidationRequests[textDocument.uri];
  if (request) {
    clearTimeout(request);
    delete pendingValidationRequests[textDocument.uri];
  }
}
function triggerValidation(textDocument) {
  cleanPendingValidation(textDocument);
  pendingValidationRequests[textDocument.uri] = setTimeout(() => {
    delete pendingValidationRequests[textDocument.uri];
    validateTextDocument(textDocument);
  }, validationDelayMs);
}
function validateTextDocument(textDocument) {
  const settingsPromise = getDocumentSettings(textDocument);
  settingsPromise.then(async (settings) => {
    const stylesheet = stylesheets.get(textDocument);
    const diagnostics = settings.validate === false ? [] : getLanguageService(textDocument).doValidation(
      textDocument,
      stylesheet
    );
    connection.sendDiagnostics({
      uri: textDocument.uri,
      diagnostics
    });
  });
}
connection.onCompletion((textDocumentPosition) => {
  const document = documents.get(textDocumentPosition.textDocument.uri);
  const stylesheet = stylesheets.get(document);
  return getLanguageService(document).doComplete(
    document,
    textDocumentPosition.position,
    stylesheet
  );
});
connection.onHover((textDocumentPosition) => {
  const document = documents.get(textDocumentPosition.textDocument.uri);
  const styleSheet = stylesheets.get(document);
  return getLanguageService(document).doHover(
    document,
    textDocumentPosition.position,
    styleSheet
  );
});
connection.onDocumentSymbol((documentSymbolParams) => {
  const document = documents.get(documentSymbolParams.textDocument.uri);
  const stylesheet = stylesheets.get(document);
  return getLanguageService(document).findDocumentSymbols(document, stylesheet);
});
connection.onDefinition((documentSymbolParams) => {
  const document = documents.get(documentSymbolParams.textDocument.uri);
  const stylesheet = stylesheets.get(document);
  return getLanguageService(document).findDefinition(
    document,
    documentSymbolParams.position,
    stylesheet
  );
});
connection.onDocumentHighlight((documentSymbolParams) => {
  const document = documents.get(documentSymbolParams.textDocument.uri);
  const stylesheet = stylesheets.get(document);
  return getLanguageService(document).findDocumentHighlights(
    document,
    documentSymbolParams.position,
    stylesheet
  );
});
connection.onReferences((referenceParams) => {
  const document = documents.get(referenceParams.textDocument.uri);
  const stylesheet = stylesheets.get(document);
  return getLanguageService(document).findReferences(
    document,
    referenceParams.position,
    stylesheet
  );
});
connection.onCodeAction((codeActionParams) => {
  const document = documents.get(codeActionParams.textDocument.uri);
  const stylesheet = stylesheets.get(document);
  return getLanguageService(document).doCodeActions(
    document,
    codeActionParams.range,
    codeActionParams.context,
    stylesheet
  );
});
connection.onDocumentSymbol((params) => {
  const document = documents.get(params.textDocument.uri);
  if (document) {
    const stylesheet = stylesheets.get(document);
    return getLanguageService(document).findDocumentSymbols(
      document,
      stylesheet
    );
  }
  return [];
});
connection.onRenameRequest((renameParameters) => {
  const document = documents.get(renameParameters.textDocument.uri);
  const stylesheet = stylesheets.get(document);
  return getLanguageService(document).doRename(
    document,
    renameParameters.position,
    renameParameters.newName,
    stylesheet
  );
});
connection.onDocumentColor((params, token) => {
  const document = documents.get(params.textDocument.uri);
  if (document) {
    const stylesheet = stylesheets.get(document);
    return getLanguageService(document).findDocumentColors(document, stylesheet);
  }
  return [];
});
connection.onColorPresentation((params, token) => {
  const document = documents.get(params.textDocument.uri);
  if (document) {
    const stylesheet = stylesheets.get(document);
    return getLanguageService(document).getColorPresentations(
      document,
      stylesheet,
      params.color,
      params.range
    );
  }
  return [];
});
connection.listen();
